{"ast":null,"code":"var toStringFunction = Function.prototype.toString;\nvar create = Object.create;\nvar toStringObject = Object.prototype.toString;\n/**\n * @classdesc Fallback cache for when WeakMap is not natively supported\n */\nvar LegacyCache = /** @class */function () {\n  function LegacyCache() {\n    this._keys = [];\n    this._values = [];\n  }\n  LegacyCache.prototype.has = function (key) {\n    return !!~this._keys.indexOf(key);\n  };\n  LegacyCache.prototype.get = function (key) {\n    return this._values[this._keys.indexOf(key)];\n  };\n  LegacyCache.prototype.set = function (key, value) {\n    this._keys.push(key);\n    this._values.push(value);\n  };\n  return LegacyCache;\n}();\nfunction createCacheLegacy() {\n  return new LegacyCache();\n}\nfunction createCacheModern() {\n  return new WeakMap();\n}\n/**\n * Get a new cache object to prevent circular references.\n */\nvar createCache = typeof WeakMap !== 'undefined' ? createCacheModern : createCacheLegacy;\n/**\n * Get an empty version of the object with the same prototype it has.\n */\nfunction getCleanClone(prototype) {\n  if (!prototype) {\n    return create(null);\n  }\n  var Constructor = prototype.constructor;\n  if (Constructor === Object) {\n    return prototype === Object.prototype ? {} : create(prototype);\n  }\n  if (Constructor && ~toStringFunction.call(Constructor).indexOf('[native code]')) {\n    try {\n      return new Constructor();\n    } catch (_a) {}\n  }\n  return create(prototype);\n}\nfunction getRegExpFlagsLegacy(regExp) {\n  var flags = '';\n  if (regExp.global) {\n    flags += 'g';\n  }\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n  return flags;\n}\nfunction getRegExpFlagsModern(regExp) {\n  return regExp.flags;\n}\n/**\n * Get the flags to apply to the copied regexp.\n */\nvar getRegExpFlags = /test/g.flags === 'g' ? getRegExpFlagsModern : getRegExpFlagsLegacy;\nfunction getTagLegacy(value) {\n  var type = toStringObject.call(value);\n  return type.substring(8, type.length - 1);\n}\nfunction getTagModern(value) {\n  return value[Symbol.toStringTag] || getTagLegacy(value);\n}\n/**\n * Get the tag of the value passed, so that the correct copier can be used.\n */\nvar getTag = typeof Symbol !== 'undefined' ? getTagModern : getTagLegacy;\nvar defineProperty = Object.defineProperty,\n  getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n  getOwnPropertyNames = Object.getOwnPropertyNames,\n  getOwnPropertySymbols = Object.getOwnPropertySymbols;\nvar _a = Object.prototype,\n  hasOwnProperty = _a.hasOwnProperty,\n  propertyIsEnumerable = _a.propertyIsEnumerable;\nvar SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === 'function';\nfunction getStrictPropertiesModern(object) {\n  return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n}\n/**\n * Get the properites used when copying objects strictly. This includes both keys and symbols.\n */\nvar getStrictProperties = SUPPORTS_SYMBOL ? getStrictPropertiesModern : getOwnPropertyNames;\n/**\n * Striclty copy all properties contained on the object.\n */\nfunction copyOwnPropertiesStrict(value, clone, state) {\n  var properties = getStrictProperties(value);\n  for (var index = 0, length_1 = properties.length, property = void 0, descriptor = void 0; index < length_1; ++index) {\n    property = properties[index];\n    if (property === 'callee' || property === 'caller') {\n      continue;\n    }\n    descriptor = getOwnPropertyDescriptor(value, property);\n    if (!descriptor) {\n      // In extra edge cases where the property descriptor cannot be retrived, fall back to\n      // the loose assignment.\n      clone[property] = state.copier(value[property], state);\n      continue;\n    }\n    // Only clone the value if actually a value, not a getter / setter.\n    if (!descriptor.get && !descriptor.set) {\n      descriptor.value = state.copier(descriptor.value, state);\n    }\n    try {\n      defineProperty(clone, property, descriptor);\n    } catch (error) {\n      // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n      clone[property] = descriptor.value;\n    }\n  }\n  return clone;\n}\n/**\n * Deeply copy the indexed values in the array.\n */\nfunction copyArrayLoose(array, state) {\n  var clone = new state.Constructor();\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(array, clone);\n  for (var index = 0, length_2 = array.length; index < length_2; ++index) {\n    clone[index] = state.copier(array[index], state);\n  }\n  return clone;\n}\n/**\n * Deeply copy the indexed values in the array, as well as any custom properties.\n */\nfunction copyArrayStrict(array, state) {\n  var clone = new state.Constructor();\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(array, clone);\n  return copyOwnPropertiesStrict(array, clone, state);\n}\n/**\n * Copy the contents of the ArrayBuffer.\n */\nfunction copyArrayBuffer(arrayBuffer, _state) {\n  return arrayBuffer.slice(0);\n}\n/**\n * Create a new Blob with the contents of the original.\n */\nfunction copyBlob(blob, _state) {\n  return blob.slice(0, blob.size, blob.type);\n}\n/**\n * Create a new DataView with the contents of the original.\n */\nfunction copyDataView(dataView, state) {\n  return new state.Constructor(copyArrayBuffer(dataView.buffer));\n}\n/**\n * Create a new Date based on the time of the original.\n */\nfunction copyDate(date, state) {\n  return new state.Constructor(date.getTime());\n}\n/**\n * Deeply copy the keys and values of the original.\n */\nfunction copyMapLoose(map, state) {\n  var clone = new state.Constructor();\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(map, clone);\n  map.forEach(function (value, key) {\n    clone.set(key, state.copier(value, state));\n  });\n  return clone;\n}\n/**\n * Deeply copy the keys and values of the original, as well as any custom properties.\n */\nfunction copyMapStrict(map, state) {\n  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);\n}\nfunction copyObjectLooseLegacy(object, state) {\n  var clone = getCleanClone(state.prototype);\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n  for (var key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = state.copier(object[key], state);\n    }\n  }\n  return clone;\n}\nfunction copyObjectLooseModern(object, state) {\n  var clone = getCleanClone(state.prototype);\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n  for (var key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = state.copier(object[key], state);\n    }\n  }\n  var symbols = getOwnPropertySymbols(object);\n  for (var index = 0, length_3 = symbols.length, symbol = void 0; index < length_3; ++index) {\n    symbol = symbols[index];\n    if (propertyIsEnumerable.call(object, symbol)) {\n      clone[symbol] = state.copier(object[symbol], state);\n    }\n  }\n  return clone;\n}\n/**\n * Deeply copy the properties (keys and symbols) and values of the original.\n */\nvar copyObjectLoose = SUPPORTS_SYMBOL ? copyObjectLooseModern : copyObjectLooseLegacy;\n/**\n * Deeply copy the properties (keys and symbols) and values of the original, as well\n * as any hidden or non-enumerable properties.\n */\nfunction copyObjectStrict(object, state) {\n  var clone = getCleanClone(state.prototype);\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n  return copyOwnPropertiesStrict(object, clone, state);\n}\n/**\n * Create a new primitive wrapper from the value of the original.\n */\nfunction copyPrimitiveWrapper(primitiveObject, state) {\n  return new state.Constructor(primitiveObject.valueOf());\n}\n/**\n * Create a new RegExp based on the value and flags of the original.\n */\nfunction copyRegExp(regExp, state) {\n  var clone = new state.Constructor(regExp.source, getRegExpFlags(regExp));\n  clone.lastIndex = regExp.lastIndex;\n  return clone;\n}\n/**\n * Return the original value (an identity function).\n *\n * @note\n * THis is used for objects that cannot be copied, such as WeakMap.\n */\nfunction copySelf(value, _state) {\n  return value;\n}\n/**\n * Deeply copy the values of the original.\n */\nfunction copySetLoose(set, state) {\n  var clone = new state.Constructor();\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(set, clone);\n  set.forEach(function (value) {\n    clone.add(state.copier(value, state));\n  });\n  return clone;\n}\n/**\n * Deeply copy the values of the original, as well as any custom properties.\n */\nfunction copySetStrict(set, state) {\n  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);\n}\nvar isArray = Array.isArray;\nvar assign = Object.assign;\nvar getPrototypeOf = Object.getPrototypeOf || function (obj) {\n  return obj.__proto__;\n};\nvar DEFAULT_LOOSE_OPTIONS = {\n  array: copyArrayLoose,\n  arrayBuffer: copyArrayBuffer,\n  blob: copyBlob,\n  dataView: copyDataView,\n  date: copyDate,\n  error: copySelf,\n  map: copyMapLoose,\n  object: copyObjectLoose,\n  regExp: copyRegExp,\n  set: copySetLoose\n};\nvar DEFAULT_STRICT_OPTIONS = assign({}, DEFAULT_LOOSE_OPTIONS, {\n  array: copyArrayStrict,\n  map: copyMapStrict,\n  object: copyObjectStrict,\n  set: copySetStrict\n});\n/**\n * Get the copiers used for each specific object tag.\n */\nfunction getTagSpecificCopiers(options) {\n  return {\n    Arguments: options.object,\n    Array: options.array,\n    ArrayBuffer: options.arrayBuffer,\n    Blob: options.blob,\n    Boolean: copyPrimitiveWrapper,\n    DataView: options.dataView,\n    Date: options.date,\n    Error: options.error,\n    Float32Array: options.arrayBuffer,\n    Float64Array: options.arrayBuffer,\n    Int8Array: options.arrayBuffer,\n    Int16Array: options.arrayBuffer,\n    Int32Array: options.arrayBuffer,\n    Map: options.map,\n    Number: copyPrimitiveWrapper,\n    Object: options.object,\n    Promise: copySelf,\n    RegExp: options.regExp,\n    Set: options.set,\n    String: copyPrimitiveWrapper,\n    WeakMap: copySelf,\n    WeakSet: copySelf,\n    Uint8Array: options.arrayBuffer,\n    Uint8ClampedArray: options.arrayBuffer,\n    Uint16Array: options.arrayBuffer,\n    Uint32Array: options.arrayBuffer,\n    Uint64Array: options.arrayBuffer\n  };\n}\n/**\n * Create a custom copier based on the object-specific copy methods passed.\n */\nfunction createCopier(options) {\n  var normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);\n  var tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);\n  var array = tagSpecificCopiers.Array,\n    object = tagSpecificCopiers.Object;\n  function copier(value, state) {\n    state.prototype = state.Constructor = undefined;\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n    if (state.cache.has(value)) {\n      return state.cache.get(value);\n    }\n    state.prototype = getPrototypeOf(value);\n    state.Constructor = state.prototype && state.prototype.constructor;\n    // plain objects\n    if (!state.Constructor || state.Constructor === Object) {\n      return object(value, state);\n    }\n    // arrays\n    if (isArray(value)) {\n      return array(value, state);\n    }\n    var tagSpecificCopier = tagSpecificCopiers[getTag(value)];\n    if (tagSpecificCopier) {\n      return tagSpecificCopier(value, state);\n    }\n    return typeof value.then === 'function' ? value : object(value, state);\n  }\n  return function copy(value) {\n    return copier(value, {\n      Constructor: undefined,\n      cache: createCache(),\n      copier: copier,\n      prototype: undefined\n    });\n  };\n}\n/**\n * Create a custom copier based on the object-specific copy methods passed, defaulting to the\n * same internals as `copyStrict`.\n */\nfunction createStrictCopier(options) {\n  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));\n}\n/**\n * Copy an value deeply as much as possible, where strict recreation of object properties\n * are maintained. All properties (including non-enumerable ones) are copied with their\n * original property descriptors on both objects and arrays.\n */\nvar copyStrict = createStrictCopier({});\n/**\n * Copy an value deeply as much as possible.\n */\nvar index = createCopier({});\nexport { copyStrict, createCopier, createStrictCopier, index as default };","map":{"version":3,"names":["toStringFunction","Function","prototype","toString","create","Object","toStringObject","LegacyCache","_keys","_values","has","key","indexOf","get","set","value","push","createCacheLegacy","createCacheModern","WeakMap","createCache","getCleanClone","Constructor","constructor","call","_a","getRegExpFlagsLegacy","regExp","flags","global","ignoreCase","multiline","unicode","sticky","getRegExpFlagsModern","getRegExpFlags","getTagLegacy","type","substring","length","getTagModern","Symbol","toStringTag","getTag","defineProperty","getOwnPropertyDescriptor","getOwnPropertyNames","getOwnPropertySymbols","hasOwnProperty","propertyIsEnumerable","SUPPORTS_SYMBOL","getStrictPropertiesModern","object","concat","getStrictProperties","copyOwnPropertiesStrict","clone","state","properties","index","length_1","property","descriptor","copier","error","copyArrayLoose","array","cache","length_2","copyArrayStrict","copyArrayBuffer","arrayBuffer","_state","slice","copyBlob","blob","size","copyDataView","dataView","buffer","copyDate","date","getTime","copyMapLoose","map","forEach","copyMapStrict","copyObjectLooseLegacy","copyObjectLooseModern","symbols","length_3","symbol","copyObjectLoose","copyObjectStrict","copyPrimitiveWrapper","primitiveObject","valueOf","copyRegExp","source","lastIndex","copySelf","copySetLoose","add","copySetStrict","isArray","Array","assign","getPrototypeOf","obj","__proto__","DEFAULT_LOOSE_OPTIONS","DEFAULT_STRICT_OPTIONS","getTagSpecificCopiers","options","Arguments","ArrayBuffer","Blob","Boolean","DataView","Date","Error","Float32Array","Float64Array","Int8Array","Int16Array","Int32Array","Map","Number","Promise","RegExp","Set","String","WeakSet","Uint8Array","Uint8ClampedArray","Uint16Array","Uint32Array","Uint64Array","createCopier","normalizedOptions","tagSpecificCopiers","undefined","tagSpecificCopier","then","copy","createStrictCopier","copyStrict"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/contentful-sdk-core/src/utils.ts","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/contentful-sdk-core/src/copier.ts","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/contentful-sdk-core/src/index.ts"],"sourcesContent":["export interface Cache {\n  has: (value: any) => boolean;\n  set: (key: any, value: any) => void;\n  get: (key: any) => any;\n}\n\nconst { toString: toStringFunction } = Function.prototype;\nconst { create } = Object;\nconst { toString: toStringObject } = Object.prototype;\n\n/**\n * @classdesc Fallback cache for when WeakMap is not natively supported\n */\nclass LegacyCache {\n  private _keys: any[] = [];\n  private _values: any[] = [];\n\n  has(key: any) {\n    return !!~this._keys.indexOf(key);\n  }\n\n  get(key: any) {\n    return this._values[this._keys.indexOf(key)];\n  }\n\n  set(key: any, value: any) {\n    this._keys.push(key);\n    this._values.push(value);\n  }\n}\n\nfunction createCacheLegacy(): Cache {\n  return new LegacyCache();\n}\n\nfunction createCacheModern(): Cache {\n  return new WeakMap();\n}\n\n/**\n * Get a new cache object to prevent circular references.\n */\nexport const createCache =\n  typeof WeakMap !== 'undefined' ? createCacheModern : createCacheLegacy;\n\n/**\n * Get an empty version of the object with the same prototype it has.\n */\nexport function getCleanClone(prototype: any): any {\n  if (!prototype) {\n    return create(null);\n  }\n\n  const Constructor = prototype.constructor;\n\n  if (Constructor === Object) {\n    return prototype === Object.prototype ? {} : create(prototype);\n  }\n\n  if (\n    Constructor &&\n    ~toStringFunction.call(Constructor).indexOf('[native code]')\n  ) {\n    try {\n      return new Constructor();\n    } catch {}\n  }\n\n  return create(prototype);\n}\n\nfunction getRegExpFlagsLegacy(regExp: RegExp): string {\n  let flags = '';\n\n  if (regExp.global) {\n    flags += 'g';\n  }\n\n  if (regExp.ignoreCase) {\n    flags += 'i';\n  }\n\n  if (regExp.multiline) {\n    flags += 'm';\n  }\n\n  if (regExp.unicode) {\n    flags += 'u';\n  }\n\n  if (regExp.sticky) {\n    flags += 'y';\n  }\n\n  return flags;\n}\n\nfunction getRegExpFlagsModern(regExp: RegExp): string {\n  return regExp.flags;\n}\n\n/**\n * Get the flags to apply to the copied regexp.\n */\nexport const getRegExpFlags =\n  /test/g.flags === 'g' ? getRegExpFlagsModern : getRegExpFlagsLegacy;\n\nfunction getTagLegacy(value: any): string {\n  const type = toStringObject.call(value);\n\n  return type.substring(8, type.length - 1);\n}\n\nfunction getTagModern(value: any): string {\n  return value[Symbol.toStringTag] || getTagLegacy(value);\n}\n\n/**\n * Get the tag of the value passed, so that the correct copier can be used.\n */\nexport const getTag =\n  typeof Symbol !== 'undefined' ? getTagModern : getTagLegacy;\n","import { getCleanClone, getRegExpFlags } from './utils';\n\nimport type { Cache } from './utils';\n\nexport type InternalCopier<Value> = (value: Value, state: State) => Value;\n\nexport interface State {\n  Constructor: any;\n  cache: Cache;\n  copier: InternalCopier<any>;\n  prototype: any;\n}\n\nconst {\n  defineProperty,\n  getOwnPropertyDescriptor,\n  getOwnPropertyNames,\n  getOwnPropertySymbols,\n} = Object;\nconst { hasOwnProperty, propertyIsEnumerable } = Object.prototype;\n\nconst SUPPORTS_SYMBOL = typeof getOwnPropertySymbols === 'function';\n\nfunction getStrictPropertiesModern(object: any): Array<string | symbol> {\n  return (getOwnPropertyNames(object) as Array<string | symbol>).concat(\n    getOwnPropertySymbols(object)\n  );\n}\n\n/**\n * Get the properites used when copying objects strictly. This includes both keys and symbols.\n */\nconst getStrictProperties = SUPPORTS_SYMBOL\n  ? getStrictPropertiesModern\n  : getOwnPropertyNames;\n\n/**\n * Striclty copy all properties contained on the object.\n */\nfunction copyOwnPropertiesStrict<Value>(\n  value: Value,\n  clone: Value,\n  state: State\n): Value {\n  const properties = getStrictProperties(value);\n\n  for (\n    let index = 0, length = properties.length, property, descriptor;\n    index < length;\n    ++index\n  ) {\n    property = properties[index];\n\n    if (property === 'callee' || property === 'caller') {\n      continue;\n    }\n\n    descriptor = getOwnPropertyDescriptor(value, property);\n\n    if (!descriptor) {\n      // In extra edge cases where the property descriptor cannot be retrived, fall back to\n      // the loose assignment.\n      (clone as any)[property] = state.copier((value as any)[property], state);\n      continue;\n    }\n\n    // Only clone the value if actually a value, not a getter / setter.\n    if (!descriptor.get && !descriptor.set) {\n      descriptor.value = state.copier(descriptor.value, state);\n    }\n\n    try {\n      defineProperty(clone, property, descriptor);\n    } catch (error) {\n      // Tee above can fail on node in edge cases, so fall back to the loose assignment.\n      (clone as any)[property] = descriptor.value;\n    }\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the indexed values in the array.\n */\nexport function copyArrayLoose(array: any[], state: State) {\n  const clone = new state.Constructor();\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(array, clone);\n\n  for (let index = 0, length = array.length; index < length; ++index) {\n    clone[index] = state.copier(array[index], state);\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the indexed values in the array, as well as any custom properties.\n */\nexport function copyArrayStrict<Value extends any[]>(\n  array: Value,\n  state: State\n) {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(array, clone);\n\n  return copyOwnPropertiesStrict(array, clone, state);\n}\n\n/**\n * Copy the contents of the ArrayBuffer.\n */\nexport function copyArrayBuffer<Value extends ArrayBuffer>(\n  arrayBuffer: Value,\n  _state: State\n): Value {\n  return arrayBuffer.slice(0) as Value;\n}\n\n/**\n * Create a new Blob with the contents of the original.\n */\nexport function copyBlob<Value extends Blob>(\n  blob: Value,\n  _state: State\n): Value {\n  return blob.slice(0, blob.size, blob.type) as Value;\n}\n\n/**\n * Create a new DataView with the contents of the original.\n */\nexport function copyDataView<Value extends DataView>(\n  dataView: Value,\n  state: State\n): Value {\n  return new state.Constructor(copyArrayBuffer(dataView.buffer, state));\n}\n\n/**\n * Create a new Date based on the time of the original.\n */\nexport function copyDate<Value extends Date>(date: Value, state: State): Value {\n  return new state.Constructor(date.getTime());\n}\n\n/**\n * Deeply copy the keys and values of the original.\n */\nexport function copyMapLoose<Value extends Map<any, any>>(\n  map: Value,\n  state: State\n): Value {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(map, clone);\n\n  map.forEach((value, key) => {\n    clone.set(key, state.copier(value, state));\n  });\n\n  return clone;\n}\n\n/**\n * Deeply copy the keys and values of the original, as well as any custom properties.\n */\nexport function copyMapStrict<Value extends Map<any, any>>(\n  map: Value,\n  state: State\n) {\n  return copyOwnPropertiesStrict(map, copyMapLoose(map, state), state);\n}\n\nfunction copyObjectLooseLegacy<Value extends Record<string, any>>(\n  object: Value,\n  state: State\n): Value {\n  const clone: any = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = state.copier(object[key], state);\n    }\n  }\n\n  return clone;\n}\n\nfunction copyObjectLooseModern<Value extends Record<string, any>>(\n  object: Value,\n  state: State\n): Value {\n  const clone = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  for (const key in object) {\n    if (hasOwnProperty.call(object, key)) {\n      clone[key] = state.copier(object[key], state);\n    }\n  }\n\n  const symbols = getOwnPropertySymbols(object);\n\n  for (\n    let index = 0, length = symbols.length, symbol;\n    index < length;\n    ++index\n  ) {\n    symbol = symbols[index];\n\n    if (propertyIsEnumerable.call(object, symbol)) {\n      clone[symbol] = state.copier((object as any)[symbol], state);\n    }\n  }\n\n  return clone;\n}\n\n/**\n * Deeply copy the properties (keys and symbols) and values of the original.\n */\nexport const copyObjectLoose = SUPPORTS_SYMBOL\n  ? copyObjectLooseModern\n  : copyObjectLooseLegacy;\n\n/**\n * Deeply copy the properties (keys and symbols) and values of the original, as well\n * as any hidden or non-enumerable properties.\n */\nexport function copyObjectStrict<Value extends Record<string, any>>(\n  object: Value,\n  state: State\n): Value {\n  const clone = getCleanClone(state.prototype);\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(object, clone);\n\n  return copyOwnPropertiesStrict(object, clone, state);\n}\n\n/**\n * Create a new primitive wrapper from the value of the original.\n */\nexport function copyPrimitiveWrapper<\n  // Specifically use the object constructor types\n  // eslint-disable-next-line @typescript-eslint/ban-types\n  Value extends Boolean | Number | String\n>(primitiveObject: Value, state: State): Value {\n  return new state.Constructor(primitiveObject.valueOf());\n}\n\n/**\n * Create a new RegExp based on the value and flags of the original.\n */\nexport function copyRegExp<Value extends RegExp>(\n  regExp: Value,\n  state: State\n): Value {\n  const clone = new state.Constructor(\n    regExp.source,\n    getRegExpFlags(regExp)\n  ) as Value;\n\n  clone.lastIndex = regExp.lastIndex;\n\n  return clone;\n}\n\n/**\n * Return the original value (an identity function).\n *\n * @note\n * THis is used for objects that cannot be copied, such as WeakMap.\n */\nexport function copySelf<Value>(value: Value, _state: State): Value {\n  return value;\n}\n\n/**\n * Deeply copy the values of the original.\n */\nexport function copySetLoose<Value extends Set<any>>(\n  set: Value,\n  state: State\n): Value {\n  const clone = new state.Constructor() as Value;\n\n  // set in the cache immediately to be able to reuse the object recursively\n  state.cache.set(set, clone);\n\n  set.forEach((value) => {\n    clone.add(state.copier(value, state));\n  });\n\n  return clone;\n}\n\n/**\n * Deeply copy the values of the original, as well as any custom properties.\n */\nexport function copySetStrict<Value extends Set<any>>(\n  set: Value,\n  state: State\n): Value {\n  return copyOwnPropertiesStrict(set, copySetLoose(set, state), state);\n}\n","import {\n  copyArrayBuffer,\n  copyArrayLoose,\n  copyArrayStrict,\n  copyBlob,\n  copyDataView,\n  copyDate,\n  copyMapLoose,\n  copyMapStrict,\n  copyObjectLoose,\n  copyObjectStrict,\n  copyPrimitiveWrapper,\n  copyRegExp,\n  copySelf,\n  copySetLoose,\n  copySetStrict,\n} from './copier';\nimport { createCache, getTag } from './utils';\n\nimport type { InternalCopier, State } from './copier';\n\nexport type { State } from './copier';\n\nconst { isArray } = Array;\nconst { assign } = Object;\nconst getPrototypeOf = Object.getPrototypeOf || ((obj) => obj.__proto__)\n\nexport interface CreateCopierOptions {\n  array?: InternalCopier<any[]>;\n  arrayBuffer?: InternalCopier<ArrayBuffer>;\n  blob?: InternalCopier<Blob>;\n  dataView?: InternalCopier<DataView>;\n  date?: InternalCopier<Date>;\n  error?: InternalCopier<any>;\n  map?: InternalCopier<Map<any, any>>;\n  object?: InternalCopier<Record<string, any>>;\n  regExp?: InternalCopier<RegExp>;\n  set?: InternalCopier<Set<any>>;\n}\n\nconst DEFAULT_LOOSE_OPTIONS: Required<CreateCopierOptions> = {\n  array: copyArrayLoose,\n  arrayBuffer: copyArrayBuffer,\n  blob: copyBlob,\n  dataView: copyDataView,\n  date: copyDate,\n  error: copySelf,\n  map: copyMapLoose,\n  object: copyObjectLoose,\n  regExp: copyRegExp,\n  set: copySetLoose,\n};\nconst DEFAULT_STRICT_OPTIONS: Required<CreateCopierOptions> = assign(\n  {},\n  DEFAULT_LOOSE_OPTIONS,\n  {\n    array: copyArrayStrict,\n    map: copyMapStrict,\n    object: copyObjectStrict,\n    set: copySetStrict,\n  }\n);\n\n/**\n * Get the copiers used for each specific object tag.\n */\nfunction getTagSpecificCopiers(\n  options: Required<CreateCopierOptions>\n): Record<string, InternalCopier<any>> {\n  return {\n    Arguments: options.object,\n    Array: options.array,\n    ArrayBuffer: options.arrayBuffer,\n    Blob: options.blob,\n    Boolean: copyPrimitiveWrapper,\n    DataView: options.dataView,\n    Date: options.date,\n    Error: options.error,\n    Float32Array: options.arrayBuffer,\n    Float64Array: options.arrayBuffer,\n    Int8Array: options.arrayBuffer,\n    Int16Array: options.arrayBuffer,\n    Int32Array: options.arrayBuffer,\n    Map: options.map,\n    Number: copyPrimitiveWrapper,\n    Object: options.object,\n    Promise: copySelf,\n    RegExp: options.regExp,\n    Set: options.set,\n    String: copyPrimitiveWrapper,\n    WeakMap: copySelf,\n    WeakSet: copySelf,\n    Uint8Array: options.arrayBuffer,\n    Uint8ClampedArray: options.arrayBuffer,\n    Uint16Array: options.arrayBuffer,\n    Uint32Array: options.arrayBuffer,\n    Uint64Array: options.arrayBuffer,\n  };\n}\n\n/**\n * Create a custom copier based on the object-specific copy methods passed.\n */\nexport function createCopier(options: CreateCopierOptions) {\n  const normalizedOptions = assign({}, DEFAULT_LOOSE_OPTIONS, options);\n  const tagSpecificCopiers = getTagSpecificCopiers(normalizedOptions);\n  const { Array: array, Object: object } = tagSpecificCopiers;\n\n  function copier(value: any, state: State): any {\n    state.prototype = state.Constructor = undefined;\n\n    if (!value || typeof value !== 'object') {\n      return value;\n    }\n\n    if (state.cache.has(value)) {\n      return state.cache.get(value);\n    }\n\n    state.prototype = getPrototypeOf(value);\n    state.Constructor = state.prototype && state.prototype.constructor;\n\n    // plain objects\n    if (!state.Constructor || state.Constructor === Object) {\n      return object(value, state);\n    }\n\n    // arrays\n    if (isArray(value)) {\n      return array(value, state);\n    }\n\n    const tagSpecificCopier = tagSpecificCopiers[getTag(value)];\n\n    if (tagSpecificCopier) {\n      return tagSpecificCopier(value, state);\n    }\n\n    return typeof value.then === 'function' ? value : object(value, state);\n  }\n\n  return function copy<Value>(value: Value): Value {\n    return copier(value, {\n      Constructor: undefined,\n      cache: createCache(),\n      copier,\n      prototype: undefined,\n    });\n  };\n}\n\n/**\n * Create a custom copier based on the object-specific copy methods passed, defaulting to the\n * same internals as `copyStrict`.\n */\nexport function createStrictCopier(options: CreateCopierOptions) {\n  return createCopier(assign({}, DEFAULT_STRICT_OPTIONS, options));\n}\n\n/**\n * Copy an value deeply as much as possible, where strict recreation of object properties\n * are maintained. All properties (including non-enumerable ones) are copied with their\n * original property descriptors on both objects and arrays.\n */\nexport const copyStrict = createStrictCopier({});\n\n/**\n * Copy an value deeply as much as possible.\n */\nexport default createCopier({});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}