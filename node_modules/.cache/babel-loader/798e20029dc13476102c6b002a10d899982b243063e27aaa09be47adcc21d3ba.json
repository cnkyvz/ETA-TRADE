{"ast":null,"code":"import isString from 'lodash/isString.js';\nimport pThrottle from 'p-throttle';\nimport { noop } from './utils.js';\nconst PERCENTAGE_REGEX = /(?<value>\\d+)(%)/;\nfunction calculateLimit(type, max = 7) {\n  let limit = max;\n  if (PERCENTAGE_REGEX.test(type)) {\n    const groups = type.match(PERCENTAGE_REGEX)?.groups;\n    if (groups && groups.value) {\n      const percentage = parseInt(groups.value) / 100;\n      limit = Math.round(max * percentage);\n    }\n  }\n  return Math.min(30, Math.max(1, limit));\n}\nfunction createThrottle(limit, logger) {\n  logger('info', `Throttle request to ${limit}/s`);\n  return pThrottle({\n    limit,\n    interval: 1000,\n    strict: false\n  });\n}\nexport default (axiosInstance, type = 'auto') => {\n  const {\n    logHandler = noop\n  } = axiosInstance.defaults;\n  let limit = isString(type) ? calculateLimit(type) : calculateLimit('auto', type);\n  let throttle = createThrottle(limit, logHandler);\n  let isCalculated = false;\n  let requestInterceptorId = axiosInstance.interceptors.request.use(config => {\n    return throttle(() => config)();\n  }, function (error) {\n    return Promise.reject(error);\n  });\n  const responseInterceptorId = axiosInstance.interceptors.response.use(response => {\n    if (!isCalculated && isString(type) && (type === 'auto' || PERCENTAGE_REGEX.test(type)) && response.headers && response.headers['x-contentful-ratelimit-second-limit']) {\n      const rawLimit = parseInt(response.headers['x-contentful-ratelimit-second-limit']);\n      const nextLimit = calculateLimit(type, rawLimit);\n      if (nextLimit !== limit) {\n        if (requestInterceptorId) {\n          axiosInstance.interceptors.request.eject(requestInterceptorId);\n        }\n        limit = nextLimit;\n        throttle = createThrottle(nextLimit, logHandler);\n        requestInterceptorId = axiosInstance.interceptors.request.use(config => {\n          return throttle(() => config)();\n        }, function (error) {\n          return Promise.reject(error);\n        });\n      }\n      isCalculated = true;\n    }\n    return response;\n  }, function (error) {\n    return Promise.reject(error);\n  });\n  return () => {\n    axiosInstance.interceptors.request.eject(requestInterceptorId);\n    axiosInstance.interceptors.response.eject(responseInterceptorId);\n  };\n};","map":{"version":3,"names":["isString","pThrottle","noop","PERCENTAGE_REGEX","calculateLimit","type","max","limit","test","groups","match","value","percentage","parseInt","Math","round","min","createThrottle","logger","interval","strict","axiosInstance","logHandler","defaults","throttle","isCalculated","requestInterceptorId","interceptors","request","use","config","error","Promise","reject","responseInterceptorId","response","headers","rawLimit","nextLimit","eject"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/contentful-sdk-core/dist/rate-limit-throttle.js"],"sourcesContent":["import isString from 'lodash/isString.js';\nimport pThrottle from 'p-throttle';\nimport { noop } from './utils.js';\nconst PERCENTAGE_REGEX = /(?<value>\\d+)(%)/;\nfunction calculateLimit(type, max = 7) {\n    let limit = max;\n    if (PERCENTAGE_REGEX.test(type)) {\n        const groups = type.match(PERCENTAGE_REGEX)?.groups;\n        if (groups && groups.value) {\n            const percentage = parseInt(groups.value) / 100;\n            limit = Math.round(max * percentage);\n        }\n    }\n    return Math.min(30, Math.max(1, limit));\n}\nfunction createThrottle(limit, logger) {\n    logger('info', `Throttle request to ${limit}/s`);\n    return pThrottle({\n        limit,\n        interval: 1000,\n        strict: false,\n    });\n}\nexport default (axiosInstance, type = 'auto') => {\n    const { logHandler = noop } = axiosInstance.defaults;\n    let limit = isString(type) ? calculateLimit(type) : calculateLimit('auto', type);\n    let throttle = createThrottle(limit, logHandler);\n    let isCalculated = false;\n    let requestInterceptorId = axiosInstance.interceptors.request.use((config) => {\n        return throttle(() => config)();\n    }, function (error) {\n        return Promise.reject(error);\n    });\n    const responseInterceptorId = axiosInstance.interceptors.response.use((response) => {\n        if (!isCalculated &&\n            isString(type) &&\n            (type === 'auto' || PERCENTAGE_REGEX.test(type)) &&\n            response.headers &&\n            response.headers['x-contentful-ratelimit-second-limit']) {\n            const rawLimit = parseInt(response.headers['x-contentful-ratelimit-second-limit']);\n            const nextLimit = calculateLimit(type, rawLimit);\n            if (nextLimit !== limit) {\n                if (requestInterceptorId) {\n                    axiosInstance.interceptors.request.eject(requestInterceptorId);\n                }\n                limit = nextLimit;\n                throttle = createThrottle(nextLimit, logHandler);\n                requestInterceptorId = axiosInstance.interceptors.request.use((config) => {\n                    return throttle(() => config)();\n                }, function (error) {\n                    return Promise.reject(error);\n                });\n            }\n            isCalculated = true;\n        }\n        return response;\n    }, function (error) {\n        return Promise.reject(error);\n    });\n    return () => {\n        axiosInstance.interceptors.request.eject(requestInterceptorId);\n        axiosInstance.interceptors.response.eject(responseInterceptorId);\n    };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}