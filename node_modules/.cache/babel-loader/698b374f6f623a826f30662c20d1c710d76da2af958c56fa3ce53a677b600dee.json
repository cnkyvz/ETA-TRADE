{"ast":null,"code":"var W = {\n    0: 8203,\n    1: 8204,\n    2: 8205,\n    3: 8290,\n    4: 8291,\n    5: 8288,\n    6: 65279,\n    7: 8289,\n    8: 119155,\n    9: 119156,\n    a: 119157,\n    b: 119158,\n    c: 119159,\n    d: 119160,\n    e: 119161,\n    f: 119162\n  },\n  L = {\n    0: 8203,\n    1: 8204,\n    2: 8205,\n    3: 65279\n  },\n  j = new Array(4).fill(String.fromCodePoint(L[0])).join(\"\"),\n  V = \"\\0\";\nfunction U(t) {\n  let n = JSON.stringify(t);\n  return \"\".concat(j).concat(Array.from(n).map(o => {\n    let e = o.charCodeAt(0);\n    if (e > 255) throw new Error(\"Only ASCII edit info can be encoded. Error attempting to encode \".concat(n, \" on character \").concat(o, \" (\").concat(e, \")\"));\n    return Array.from(e.toString(4).padStart(4, \"0\")).map(r => String.fromCodePoint(L[r])).join(\"\");\n  }).join(\"\"));\n}\nfunction Z(t) {\n  return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);\n}\nfunction q(t) {\n  try {\n    new URL(t, t.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch (n) {\n    return !1;\n  }\n  return !0;\n}\nfunction G(t, n) {\n  let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \"auto\";\n  return o === !0 || o === \"auto\" && (Z(t) || q(t)) ? t : \"\".concat(t).concat(U(n));\n}\nvar H = Object.fromEntries(Object.entries(L).map(t => t.reverse())),\n  k = Object.fromEntries(Object.entries(W).map(t => t.reverse())),\n  K = \"\".concat(Object.values(W).map(t => \"\\\\u{\".concat(t.toString(16), \"}\")).join(\"\")),\n  O = new RegExp(\"[\".concat(K, \"]{4,}\"), \"gu\");\nfunction X(t) {\n  let n = t.match(O);\n  if (n) return Y(n[0], !0)[0];\n}\nfunction Y(t) {\n  let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : !1;\n  let o = Array.from(t);\n  if (o.length % 2 === 0) {\n    if (o.length % 4 || !t.startsWith(j)) return ee(o, n);\n  } else throw new Error(\"Encoded data has invalid length\");\n  let e = [];\n  for (let r = o.length * 0.25; r--;) {\n    let s = o.slice(r * 4, r * 4 + 4).map(c => H[c.codePointAt(0)]).join(\"\");\n    e.unshift(String.fromCharCode(parseInt(s, 4)));\n  }\n  if (n) {\n    e.shift();\n    let r = e.indexOf(V);\n    return r === -1 && (r = e.length), [JSON.parse(e.slice(0, r).join(\"\"))];\n  }\n  return e.join(\"\").split(V).filter(Boolean).map(r => JSON.parse(r));\n}\nfunction ee(t, n) {\n  var o;\n  let e = [];\n  for (let i = t.length * 0.5; i--;) {\n    let u = \"\".concat(k[t[i * 2].codePointAt(0)]).concat(k[t[i * 2 + 1].codePointAt(0)]);\n    e.unshift(String.fromCharCode(parseInt(u, 16)));\n  }\n  let r = [],\n    s = [e.join(\"\")],\n    c = 10;\n  for (; s.length;) {\n    let i = s.shift();\n    try {\n      if (r.push(JSON.parse(i)), n) return r;\n    } catch (u) {\n      if (!c--) throw u;\n      let a = +((o = u.message.match(/\\sposition\\s(\\d+)$/)) == null ? void 0 : o[1]);\n      if (!a) throw u;\n      s.unshift(i.substring(0, a), i.substring(a));\n    }\n  }\n  return r;\n}\nfunction te(t) {\n  var n;\n  return {\n    cleaned: t.replace(O, \"\"),\n    encoded: ((n = t.match(O)) == null ? void 0 : n[0]) || \"\"\n  };\n}\nfunction w(t, n) {\n  return G(t, n);\n}\nfunction ce(t) {\n  return U(t);\n}\nfunction ie(t) {\n  return X(t);\n}\nfunction ae(t) {\n  return te(t);\n}\nvar x, F;\nfunction ne() {\n  if (F) return x;\n  F = 1;\n  var t = Object.prototype.hasOwnProperty,\n    n = Object.prototype.toString;\n  return x = function (e, r, s) {\n    if (n.call(r) !== \"[object Function]\") throw new TypeError(\"iterator must be a function\");\n    var c = e.length;\n    if (c === +c) for (var i = 0; i < c; i++) r.call(s, e[i], i, e);else for (var u in e) t.call(e, u) && r.call(s, e[u], u, e);\n  }, x;\n}\nvar I, _;\nfunction re() {\n  if (_) return I;\n  _ = 1;\n  var t = ne();\n  I = n;\n  function n(o, e, r) {\n    if (arguments.length === 3) return n.set(o, e, r);\n    if (arguments.length === 2) return n.get(o, e);\n    var s = n.bind(n, o);\n    for (var c in n) n.hasOwnProperty(c) && (s[c] = n[c].bind(s, o));\n    return s;\n  }\n  return n.get = function (e, r) {\n    for (var s = Array.isArray(r) ? r : n.parse(r), c = 0; c < s.length; ++c) {\n      var i = s[c];\n      if (!(typeof e == \"object\" && i in e)) throw new Error(\"Invalid reference token: \" + i);\n      e = e[i];\n    }\n    return e;\n  }, n.set = function (e, r, s) {\n    var c = Array.isArray(r) ? r : n.parse(r),\n      i = c[0];\n    if (c.length === 0) throw Error(\"Can not set the root object\");\n    for (var u = 0; u < c.length - 1; ++u) {\n      var a = c[u];\n      typeof a != \"string\" && typeof a != \"number\" && (a = String(a)), !(a === \"__proto__\" || a === \"constructor\" || a === \"prototype\") && (a === \"-\" && Array.isArray(e) && (a = e.length), i = c[u + 1], a in e || (i.match(/^(\\d+|-)$/) ? e[a] = [] : e[a] = {}), e = e[a]);\n    }\n    return i === \"-\" && Array.isArray(e) && (i = e.length), e[i] = s, this;\n  }, n.remove = function (o, e) {\n    var r = Array.isArray(e) ? e : n.parse(e),\n      s = r[r.length - 1];\n    if (s === void 0) throw new Error('Invalid JSON pointer for remove: \"' + e + '\"');\n    var c = n.get(o, r.slice(0, -1));\n    if (Array.isArray(c)) {\n      var i = +s;\n      if (s === \"\" && isNaN(i)) throw new Error('Invalid array index: \"' + s + '\"');\n      Array.prototype.splice.call(c, i, 1);\n    } else delete c[s];\n  }, n.dict = function (e, r) {\n    var s = {};\n    return n.walk(e, function (c, i) {\n      s[i] = c;\n    }, r), s;\n  }, n.walk = function (e, r, s) {\n    var c = [];\n    s = s || function (i) {\n      var u = Object.prototype.toString.call(i);\n      return u === \"[object Object]\" || u === \"[object Array]\";\n    }, function i(u) {\n      t(u, function (a, l) {\n        c.push(String(l)), s(a) ? i(a) : r(a, n.compile(c)), c.pop();\n      });\n    }(e);\n  }, n.has = function (e, r) {\n    try {\n      n.get(e, r);\n    } catch (s) {\n      return !1;\n    }\n    return !0;\n  }, n.escape = function (e) {\n    return e.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n  }, n.unescape = function (e) {\n    return e.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n  }, n.parse = function (e) {\n    if (e === \"\") return [];\n    if (e.charAt(0) !== \"/\") throw new Error(\"Invalid JSON pointer: \" + e);\n    return e.substring(1).split(/\\//).map(n.unescape);\n  }, n.compile = function (e) {\n    return e.length === 0 ? \"\" : \"/\" + e.map(n.escape).join(\"/\");\n  }, I;\n}\nvar p = re();\nconst oe = _ref => {\n    let {\n      pointer: t,\n      mappings: n,\n      data: o,\n      hiddenStrings: e\n    } = _ref;\n    const r = n[t];\n    if (r) {\n      delete n[t];\n      const s = C(o, t);\n      for (const c of s) {\n        n[c] = r;\n        const i = p.get(o, c),\n          u = w(i, e);\n        p.set(o, c, u);\n      }\n    } else {\n      const s = C(o, t);\n      for (const c of s) {\n        const i = p.get(o, c),\n          u = w(i, e);\n        p.set(o, c, u);\n      }\n    }\n  },\n  C = function (t) {\n    let n = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n    const o = [],\n      e = p.get(t, n);\n    if (e.content) for (let r = 0; r < e.content.length; r++) e.content[r].nodeType === \"text\" ? o.push(\"\".concat(n, \"/content/\").concat(r, \"/value\")) : o.push(...C(t, \"\".concat(n, \"/content/\").concat(r)));\n    return o;\n  },\n  b = _ref2 => {\n    let {\n      entityId: t,\n      entityType: n,\n      space: o,\n      environment: e,\n      field: r,\n      locale: s,\n      editorInterface: c,\n      fieldType: i,\n      targetOrigin: u,\n      platform: a\n    } = _ref2;\n    const d = {\n      origin: \"contentful.com\",\n      href: \"\".concat(\"\".concat(u || \"https://app.contentful.com\", \"/spaces/\").concat(o, \"/environments/\").concat(e), \"/\", n === \"Entry\" ? \"entries\" : \"assets\", \"/\").concat(t, \"/?focusedField=\").concat(r, \"&focusedLocale=\").concat(s, \"&source=vercel-content-link\"),\n      contentful: {\n        editorInterface: c,\n        fieldType: i\n      }\n    };\n    return a === \"vercel\" && delete d.contentful, d;\n  },\n  B = t => [\"builtin\", \"sidebar-builtin\", \"editor-builtin\"].includes(t),\n  D = t => se.includes(t);\nfunction Q(t) {\n  if (typeof structuredClone == \"function\") return structuredClone(t);\n  try {\n    return JSON.parse(JSON.stringify(t));\n  } catch (n) {\n    return console.warn(\"Failed to clone data:\", t, n), t;\n  }\n}\nconst se = [\"singleLine\", \"tagEditor\", \"listInput\", \"checkbox\", \"richTextEditor\", \"multipleLine\"];\nfunction P(t, n, o, e, r, s, c) {\n  const i = c ? n[c] : n;\n  switch (t) {\n    case \"Symbol\":\n      {\n        const u = w(i, o);\n        p.set(e, r, u);\n        break;\n      }\n    case \"Text\":\n      {\n        const u = w(i, o);\n        p.set(e, r, u);\n        break;\n      }\n    case \"RichText\":\n      {\n        oe({\n          pointer: \"\",\n          mappings: s,\n          data: i,\n          hiddenStrings: o\n        });\n        break;\n      }\n    case \"Array\":\n      {\n        const u = i.map(a => typeof a == \"string\" ? w(a, o) : a);\n        p.set(e, r, u);\n        break;\n      }\n  }\n}\nconst ue = (t, n, o) => {\n    if (!t || !t.extensions || !t.extensions.contentSourceMaps) return console.error(\"GraphQL response does not contain Content Source Maps information.\", t), t;\n    const e = Q(t),\n      {\n        spaces: r,\n        environments: s,\n        editorInterfaces: c,\n        fields: i,\n        locales: u,\n        entries: a,\n        assets: l,\n        mappings: m,\n        fieldTypes: v\n      } = e.extensions.contentSourceMaps,\n      y = e;\n    for (const d in m) {\n      const {\n          source: f\n        } = m[d],\n        h = \"entry\" in f ? a[f.entry] : l[f.asset],\n        M = \"entry\" in f ? \"Entry\" : \"Asset\";\n      if (!h) return e;\n      const g = r[h.space],\n        A = s[h.environment],\n        E = h.id,\n        S = i[f.field],\n        T = u[f.locale],\n        N = c[f.editorInterface],\n        J = v[f.fieldType];\n      if (!(B(N.widgetNamespace) && !D(N.widgetId)) && p.has(y, d)) {\n        const R = p.get(y, d);\n        if (R !== null) {\n          const z = b({\n            entityId: E,\n            entityType: M,\n            space: g,\n            environment: A,\n            field: S,\n            locale: T,\n            editorInterface: N,\n            fieldType: J,\n            targetOrigin: n,\n            platform: o\n          });\n          P(J, R, z, y, d, m);\n        }\n      }\n    }\n    return e;\n  },\n  $ = (t, n, o, e, r) => {\n    if (!t.fields) return;\n    const {\n      contentSourceMaps: s\n    } = t.sys;\n    if (!s) {\n      console.error(\"Content source maps data is missing\");\n      return;\n    }\n    const {\n      mappings: c\n    } = s;\n    for (const i in c) {\n      const {\n          source: u\n        } = c[i],\n        a = t.sys.space.sys.id,\n        l = t.sys.environment.sys.id,\n        m = t.sys.id,\n        v = t.sys.type,\n        y = n[u.fieldType],\n        d = o[u.editorInterface];\n      if (B(d.widgetNamespace) && !D(d.widgetId)) continue;\n      const f = i.startsWith(\"/\") ? i : \"/\".concat(i);\n      if (p.has(t, f)) {\n        const h = p.get(t, f);\n        if (h === null) return;\n        const g = f.split(\"/\").pop();\n        if (!g) {\n          console.error(\"Field name could not be extracted from the pointer\", f);\n          return;\n        }\n        const A = t.sys.locale;\n        if (A) {\n          const E = b({\n            entityId: m,\n            entityType: v,\n            space: a,\n            environment: l,\n            field: g,\n            locale: A,\n            editorInterface: d,\n            fieldType: y,\n            targetOrigin: e,\n            platform: r\n          });\n          P(y, h, E, t, f, c);\n        } else Object.keys(h).forEach(S => {\n          const T = b({\n            entityId: m,\n            entityType: v,\n            space: a,\n            environment: l,\n            field: g,\n            locale: S,\n            editorInterface: d,\n            fieldType: y,\n            targetOrigin: e,\n            platform: r\n          });\n          P(y, h, T, t, \"\".concat(f, \"/\").concat(S), c, S);\n        });\n      }\n    }\n  },\n  fe = (t, n, o) => {\n    var r;\n    const e = Q(t);\n    if (e.sys && \"items\" in e) {\n      const s = e;\n      if (!((r = s.sys) != null && r.contentSourceMapsLookup)) return console.error(\"Content source maps lookup data is missing\"), s;\n      const {\n          contentSourceMapsLookup: {\n            fieldTypes: c,\n            editorInterfaces: i\n          }\n        } = s.sys,\n        {\n          items: u,\n          includes: a\n        } = s;\n      u.forEach(l => $(l, c, i, n, o)), a && a.Entry && a.Entry.forEach(l => $(l, c, i, n, o)), a && a.Asset && a.Asset.forEach(l => $(l, c, i, n, o));\n    } else {\n      const s = e;\n      if (!s.sys.contentSourceMapsLookup) return console.error(\"Content source maps lookup data is missing\"), s;\n      $(s, s.sys.contentSourceMapsLookup.fieldTypes, s.sys.contentSourceMapsLookup.editorInterfaces, n, o);\n    }\n    return e;\n  };\nexport { se as SUPPORTED_WIDGETS, Q as clone, w as combine, b as createSourceMapMetadata, ie as decode, ce as encode, fe as encodeCPAResponse, P as encodeField, ue as encodeGraphQLResponse, oe as encodeRichTextValue, B as isBuiltinNamespace, D as isSupportedWidget, ae as splitEncoding };","map":{"version":3,"names":["W","a","b","c","d","e","f","L","j","Array","fill","String","fromCodePoint","join","V","U","t","n","JSON","stringify","concat","from","map","o","charCodeAt","Error","toString","padStart","r","Z","Number","isNaN","test","Date","parse","q","URL","startsWith","G","arguments","length","undefined","H","Object","fromEntries","entries","reverse","k","K","values","O","RegExp","X","match","Y","ee","s","slice","codePointAt","unshift","fromCharCode","parseInt","shift","indexOf","split","filter","Boolean","i","u","push","message","substring","te","cleaned","replace","encoded","w","ce","ie","ae","prototype","hasOwnProperty","x","foreach","call","TypeError","ne","I","set","get","bind","isArray","remove","splice","dict","walk","l","compile","pop","has","escape","unescape","charAt","oe","_ref","pointer","mappings","data","hiddenStrings","C","p","findRichTextNodes","content","nodeType","_ref2","entityId","entityType","space","environment","field","locale","editorInterface","fieldType","targetOrigin","platform","origin","href","contentful","B","includes","D","se","Q","structuredClone","console","warn","P","ue","encodeGraphQLResponse","extensions","contentSourceMaps","error","spaces","environments","editorInterfaces","fields","locales","assets","m","fieldTypes","v","y","source","h","entry","asset","M","g","A","E","id","S","T","N","J","widgetNamespace","widgetId","R","z","$","applyEncoding","sys","type","keys","forEach","fe","encodeCPAResponse","contentSourceMapsLookup","items","Entry","Asset"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/node_modules/@vercel/stega/dist/index.mjs","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/@contentful/content-source-maps/src/encode.ts","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/node_modules/foreach/index.js","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/node_modules/json-pointer/index.js","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/@contentful/content-source-maps/src/richText.ts","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/@contentful/content-source-maps/src/utils.ts","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/@contentful/content-source-maps/src/graphql/encodeGraphQLResponse.ts","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/@contentful/content-source-maps/src/rest/encodeCPAResponse.ts"],"sourcesContent":["var s={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},c={0:8203,1:8204,2:8205,3:65279},u=new Array(4).fill(String.fromCodePoint(c[0])).join(\"\"),m=String.fromCharCode(0);function E(t){let e=JSON.stringify(t);return`${u}${Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(4).padStart(4,\"0\")).map(o=>String.fromCodePoint(c[o])).join(\"\")}).join(\"\")}`}function y(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(o=>String.fromCodePoint(s[o])).join(\"\")}).join(\"\")}function I(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:Boolean(Date.parse(t))}function T(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function C(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(I(t)||T(t))?t:`${t}${E(e)}`}var x=Object.fromEntries(Object.entries(c).map(t=>t.reverse())),g=Object.fromEntries(Object.entries(s).map(t=>t.reverse())),S=`${Object.values(s).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,f=new RegExp(`[${S}]{4,}`,\"gu\");function G(t){let e=t.match(f);if(!!e)return h(e[0],!0)[0]}function $(t){let e=t.match(f);if(!!e)return e.map(r=>h(r)).flat()}function h(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(u))return A(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=[];for(let o=r.length*.25;o--;){let p=r.slice(o*4,o*4+4).map(d=>x[d.codePointAt(0)]).join(\"\");n.unshift(String.fromCharCode(parseInt(p,4)))}if(e){n.shift();let o=n.indexOf(m);return o===-1&&(o=n.length),[JSON.parse(n.slice(0,o).join(\"\"))]}return n.join(\"\").split(m).filter(Boolean).map(o=>JSON.parse(o))}function A(t,e){var d;let r=[];for(let i=t.length*.5;i--;){let a=`${g[t[i*2].codePointAt(0)]}${g[t[i*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(a,16)))}let n=[],o=[r.join(\"\")],p=10;for(;o.length;){let i=o.shift();try{if(n.push(JSON.parse(i)),e)return n}catch(a){if(!p--)throw a;let l=+((d=a.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:d[1]);if(!l)throw a;o.unshift(i.substring(0,l),i.substring(l))}}return n}function _(t){var e;return{cleaned:t.replace(f,\"\"),encoded:((e=t.match(f))==null?void 0:e[0])||\"\"}}function O(t){return t&&JSON.parse(_(JSON.stringify(t)).cleaned)}export{f as VERCEL_STEGA_REGEX,y as legacyStegaEncode,O as vercelStegaClean,C as vercelStegaCombine,G as vercelStegaDecode,$ as vercelStegaDecodeAll,E as vercelStegaEncode,_ as vercelStegaSplit};\n","import {\n  vercelStegaCombine,\n  vercelStegaDecode,\n  vercelStegaEncode,\n  vercelStegaSplit,\n} from '@vercel/stega';\n\nimport type { SourceMapMetadata } from './types.js';\n\nexport function combine(text: string, metadata: SourceMapMetadata): string {\n  return vercelStegaCombine(text, metadata);\n}\n\nexport function encode(metadata: SourceMapMetadata): string {\n  return vercelStegaEncode(metadata);\n}\n\nexport function decode(text: string): SourceMapMetadata | undefined {\n  return vercelStegaDecode(text);\n}\n\nexport function splitEncoding(text: string): {\n  /** The original string with encoded substring removed */\n  cleaned: string;\n  /** The encoded substring from the original string */\n  encoded: string;\n} {\n  return vercelStegaSplit(text);\n}\n","\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n","'use strict';\n\nvar each = require('foreach');\nmodule.exports = api;\n\n\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api (obj, pointer, value) {\n    // .set()\n    if (arguments.length === 3) {\n        return api.set(obj, pointer, value);\n    }\n    // .get()\n    if (arguments.length === 2) {\n        return api.get(obj, pointer);\n    }\n    // Return a partially applied function on `obj`.\n    var wrapped = api.bind(api, obj);\n\n    // Support for oo style\n    for (var name in api) {\n        if (api.hasOwnProperty(name)) {\n            wrapped[name] = api[name].bind(wrapped, obj);\n        }\n    }\n    return wrapped;\n}\n\n\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\napi.get = function get (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n    for (var i = 0; i < refTokens.length; ++i) {\n        var tok = refTokens[i];\n        if (!(typeof obj == 'object' && tok in obj)) {\n            throw new Error('Invalid reference token: ' + tok);\n        }\n        obj = obj[tok];\n    }\n    return obj;\n};\n\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\napi.set = function set (obj, pointer, value) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n    if (refTokens.length === 0) {\n      throw Error('Can not set the root object');\n    }\n\n    for (var i = 0; i < refTokens.length - 1; ++i) {\n        var tok = refTokens[i];\n        if (typeof tok !== 'string' && typeof tok !== 'number') {\n          tok = String(tok)\n        }\n        if (tok === \"__proto__\" || tok === \"constructor\" || tok === \"prototype\") {\n            continue\n        }\n        if (tok === '-' && Array.isArray(obj)) {\n          tok = obj.length;\n        }\n        nextTok = refTokens[i + 1];\n\n        if (!(tok in obj)) {\n            if (nextTok.match(/^(\\d+|-)$/)) {\n                obj[tok] = [];\n            } else {\n                obj[tok] = {};\n            }\n        }\n        obj = obj[tok];\n    }\n    if (nextTok === '-' && Array.isArray(obj)) {\n      nextTok = obj.length;\n    }\n    obj[nextTok] = value;\n    return this;\n};\n\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\napi.remove = function (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n    var finalToken = refTokens[refTokens.length -1];\n    if (finalToken === undefined) {\n        throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n    }\n\n    var parent = api.get(obj, refTokens.slice(0, -1));\n    if (Array.isArray(parent)) {\n      var index = +finalToken;\n      if (finalToken === '' && isNaN(index)) {\n        throw new Error('Invalid array index: \"' + finalToken + '\"');\n      }\n\n      Array.prototype.splice.call(parent, index, 1);\n    } else {\n      delete parent[finalToken];\n    }\n};\n\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\napi.dict = function dict (obj, descend) {\n    var results = {};\n    api.walk(obj, function (value, pointer) {\n        results[pointer] = value;\n    }, descend);\n    return results;\n};\n\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\napi.walk = function walk (obj, iterator, descend) {\n    var refTokens = [];\n\n    descend = descend || function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Object]' || type === '[object Array]';\n    };\n\n    (function next (cur) {\n        each(cur, function (value, key) {\n            refTokens.push(String(key));\n            if (descend(value)) {\n                next(value);\n            } else {\n                iterator(value, api.compile(refTokens));\n            }\n            refTokens.pop();\n        });\n    }(obj));\n};\n\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\napi.has = function has (obj, pointer) {\n    try {\n        api.get(obj, pointer);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.escape = function escape (str) {\n    return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.unescape = function unescape (str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\napi.parse = function parse (pointer) {\n    if (pointer === '') { return []; }\n    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }\n    return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\napi.compile = function compile (refTokens) {\n    if (refTokens.length === 0) { return ''; }\n    return '/' + refTokens.map(api.escape).join('/');\n};\n","import { get, set } from 'json-pointer';\n\nimport { combine } from './encode.js';\nimport type { CPAMappings, GraphQLMappings, SourceMapMetadata } from './types.js';\n\nexport const encodeRichTextValue = ({\n  pointer,\n  mappings,\n  data,\n  hiddenStrings,\n}: {\n  pointer: string;\n  mappings: CPAMappings | GraphQLMappings;\n  data: Node;\n  hiddenStrings: SourceMapMetadata;\n}) => {\n  const source = mappings[pointer];\n\n  // Only proceed with mapping if we have a valid source\n  if (source) {\n    // We can now safely delete the original pointer as we've preserved the source\n    delete mappings[pointer];\n\n    const textNodes = findRichTextNodes(data, pointer);\n    for (const textNode of textNodes) {\n      mappings[textNode] = source;\n      const currentTextNodeValue = get(data, textNode);\n      const encodedValue = combine(currentTextNodeValue, hiddenStrings);\n      set(data, textNode, encodedValue);\n    }\n  } else {\n    // If there's no source mapping, just encode the text nodes without creating mappings\n    const textNodes = findRichTextNodes(data, pointer);\n    for (const textNode of textNodes) {\n      const currentTextNodeValue = get(data, textNode);\n      const encodedValue = combine(currentTextNodeValue, hiddenStrings);\n      set(data, textNode, encodedValue);\n    }\n  }\n};\n\nconst findRichTextNodes = (data: Node, currentPath = ''): string[] => {\n  const textNodes = [];\n  const node = get(data, currentPath);\n\n  if (node.content) {\n    for (let i = 0; i < node.content.length; i++) {\n      if (node.content[i].nodeType === 'text') {\n        textNodes.push(`${currentPath}/content/${i}/value`);\n      } else {\n        textNodes.push(...findRichTextNodes(data, `${currentPath}/content/${i}`));\n      }\n    }\n  }\n\n  return textNodes;\n};\n","import { set } from 'json-pointer';\n\nimport { combine } from './encode.js';\nimport { encodeRichTextValue } from './richText.js';\nimport type {\n  CPAEntry,\n  CPAMappings,\n  CreateSourceMapParams,\n  FieldType,\n  GraphQLMappings,\n  GraphQLResponse,\n  SourceMapMetadata,\n  WidgetId,\n  WidgetNamespace,\n} from './types.js';\n\nexport const createSourceMapMetadata = ({\n  entityId,\n  entityType,\n  space,\n  environment,\n  field,\n  locale,\n  editorInterface,\n  fieldType,\n  targetOrigin,\n  platform,\n}: CreateSourceMapParams): SourceMapMetadata => {\n  const targetOriginUrl = targetOrigin || 'https://app.contentful.com';\n  const basePath = `${targetOriginUrl}/spaces/${space}/environments/${environment}`;\n  const entityRoute = entityType === 'Entry' ? 'entries' : 'assets';\n  const href = `${basePath}/${entityRoute}/${entityId}/?focusedField=${field}&focusedLocale=${locale}&source=vercel-content-link`;\n\n  const result: SourceMapMetadata = {\n    origin: 'contentful.com',\n    href,\n    contentful: {\n      editorInterface,\n      fieldType,\n    },\n  };\n\n  // If the user has specified a platform, we remove the fields that are not relevant to that platform\n  if (platform === 'vercel') {\n    delete result.contentful;\n  }\n\n  return result;\n};\n\nexport const isBuiltinNamespace = (namespace: WidgetNamespace) =>\n  ['builtin', 'sidebar-builtin', 'editor-builtin'].includes(namespace);\nexport const isSupportedWidget = (widgetId: WidgetId) => SUPPORTED_WIDGETS.includes(widgetId);\n\n/**\n * Clones the incoming element into a new one, to prevent modification on the original object\n * Hint: It uses the structuredClone which is only available in modern browsers,\n * for older one it uses the JSON.parse(JSON.stringify) hack.\n */\nexport function clone<T extends Record<string, unknown> | Array<unknown>>(incoming: T): T {\n  if (typeof structuredClone === 'function') {\n    return structuredClone(incoming);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(incoming));\n  } catch (err) {\n    console.warn('Failed to clone data:', incoming, err);\n    return incoming;\n  }\n}\n\nexport const SUPPORTED_WIDGETS: WidgetId[] = [\n  'singleLine',\n  'tagEditor',\n  'listInput',\n  'checkbox',\n  'richTextEditor',\n  'multipleLine',\n];\n\nexport function encodeField(\n  fieldType: FieldType,\n  currentValue: any,\n  hiddenStrings: SourceMapMetadata,\n  target: GraphQLResponse | CPAEntry,\n  pointer: string,\n  mappings: CPAMappings | GraphQLMappings,\n  locale?: string,\n) {\n  // Determine the value based on locale (if provided)\n  const value = locale ? currentValue[locale] : currentValue;\n\n  // Process based on fieldType\n  switch (fieldType) {\n    case 'Symbol': {\n      const encodedValue = combine(value, hiddenStrings);\n      set(target, pointer, encodedValue);\n      break;\n    }\n\n    case 'Text': {\n      const encodedValue = combine(value, hiddenStrings);\n      set(target, pointer, encodedValue);\n      break;\n    }\n\n    case 'RichText': {\n      encodeRichTextValue({\n        pointer: '',\n        mappings,\n        data: value,\n        hiddenStrings,\n      });\n      break;\n    }\n\n    case 'Array': {\n      const encodedArray = value.map((item: unknown) => {\n        if (typeof item === 'string') {\n          return combine(item, hiddenStrings);\n        } else {\n          return item; // Return the item unchanged if it's not a string\n        }\n      });\n      set(target, pointer, encodedArray);\n      break;\n    }\n  }\n}\n","import { get, has } from 'json-pointer';\n\nimport type { CreateSourceMapParams } from '../types.js';\nimport {\n  clone,\n  createSourceMapMetadata,\n  encodeField,\n  isBuiltinNamespace,\n  isSupportedWidget,\n} from '../utils.js';\n\nexport const encodeGraphQLResponse = <TResponse extends { data: any; extensions: any }>(\n  originalGraphqlResponse: TResponse,\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n): TResponse => {\n  if (\n    !originalGraphqlResponse ||\n    !originalGraphqlResponse.extensions ||\n    !originalGraphqlResponse.extensions.contentSourceMaps\n  ) {\n    console.error(\n      'GraphQL response does not contain Content Source Maps information.',\n      originalGraphqlResponse,\n    );\n    return originalGraphqlResponse;\n  }\n  const modifiedGraphqlResponse = clone(originalGraphqlResponse);\n  const {\n    spaces,\n    environments,\n    editorInterfaces,\n    fields,\n    locales,\n    entries,\n    assets,\n    mappings,\n    fieldTypes,\n  } = modifiedGraphqlResponse.extensions.contentSourceMaps;\n  const target = modifiedGraphqlResponse;\n\n  for (const pointer in mappings) {\n    const { source } = mappings[pointer];\n\n    const entity = 'entry' in source ? entries[source.entry] : assets[source.asset];\n    const entityType = 'entry' in source ? 'Entry' : 'Asset';\n\n    if (!entity) {\n      return modifiedGraphqlResponse;\n    }\n\n    const space = spaces[entity.space];\n    const environment = environments[entity.environment];\n    const entityId = entity.id;\n    const field = fields[source.field];\n    const locale = locales[source.locale];\n    const editorInterface = editorInterfaces[source.editorInterface];\n    const fieldType = fieldTypes[source.fieldType];\n\n    // Skip unsupported widgets\n    if (\n      isBuiltinNamespace(editorInterface.widgetNamespace) &&\n      !isSupportedWidget(editorInterface.widgetId)\n    ) {\n      continue;\n    }\n\n    if (has(target, pointer)) {\n      const currentValue = get(target, pointer);\n\n      if (currentValue !== null) {\n        const hiddenStrings = createSourceMapMetadata({\n          entityId,\n          entityType,\n          space,\n          environment,\n          field,\n          locale,\n          editorInterface,\n          fieldType,\n          targetOrigin,\n          platform,\n        });\n\n        encodeField(fieldType, currentValue, hiddenStrings, target, pointer, mappings);\n      }\n    } else {\n      //@TODO - add Sentry logging\n      // console.warn(`Pointer ${pointer} not found in the entry`, target);\n    }\n  }\n  return modifiedGraphqlResponse;\n};\n","import { get, has } from 'json-pointer';\n\nimport type {\n  CPAEntry,\n  CPAEntryCollection,\n  EditorInterfaceSource,\n  FieldType,\n  CreateSourceMapParams,\n} from '../types.js';\nimport {\n  clone,\n  createSourceMapMetadata,\n  encodeField,\n  isBuiltinNamespace,\n  isSupportedWidget,\n} from '../utils.js';\n\nconst applyEncoding = (\n  target: CPAEntry,\n  fieldTypes: FieldType[],\n  editorInterfaces: EditorInterfaceSource[],\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n) => {\n  if (!target.fields) {\n    return;\n  }\n\n  const { contentSourceMaps } = target.sys;\n\n  if (!contentSourceMaps) {\n    console.error('Content source maps data is missing');\n    return;\n  }\n\n  const { mappings } = contentSourceMaps;\n\n  for (const pointer in mappings) {\n    const { source } = mappings[pointer];\n    const space = target.sys.space.sys.id;\n    const environment = target.sys.environment.sys.id;\n    const entityId = target.sys.id;\n    const entityType = target.sys.type;\n    const fieldType = fieldTypes[source.fieldType];\n    const editorInterface = editorInterfaces[source.editorInterface];\n\n    // Skip unsupported widgets\n    if (\n      isBuiltinNamespace(editorInterface.widgetNamespace) &&\n      !isSupportedWidget(editorInterface.widgetId)\n    ) {\n      continue;\n    }\n\n    const formattedPointer = pointer.startsWith('/') ? pointer : `/${pointer}`;\n\n    if (has(target, formattedPointer)) {\n      const currentValue = get(target, formattedPointer);\n      if (currentValue === null) {\n        return;\n      }\n      const fieldParts = formattedPointer.split('/'); // Split the pointer into parts\n      const field = fieldParts.pop(); // Get the last part, which is the field name\n      if (!field) {\n        console.error('Field name could not be extracted from the pointer', formattedPointer);\n        return;\n      }\n      const locale = target.sys.locale;\n\n      // Determine if we are dealing with multiple locale values in the response or just a single locale\n      if (locale) {\n        const hiddenStrings = createSourceMapMetadata({\n          entityId,\n          entityType,\n          space,\n          environment,\n          field,\n          locale,\n          editorInterface,\n          fieldType,\n          targetOrigin,\n          platform,\n        });\n\n        encodeField(fieldType, currentValue, hiddenStrings, target, formattedPointer, mappings);\n      } else {\n        const locales = Object.keys(currentValue);\n        locales.forEach((locale) => {\n          const hiddenStrings = createSourceMapMetadata({\n            entityId,\n            entityType,\n            space,\n            environment,\n            field,\n            locale,\n            editorInterface,\n            fieldType,\n            targetOrigin,\n            platform,\n          });\n\n          encodeField(\n            fieldType,\n            currentValue,\n            hiddenStrings,\n            target,\n            `${formattedPointer}/${locale}`,\n            mappings,\n            locale,\n          );\n        });\n      }\n    } else {\n      //@TODO - add Sentry logging\n      // console.warn(`Pointer ${pointer} not found in the entry`, target);\n    }\n  }\n};\n\nexport const encodeCPAResponse = (\n  CPAResponse: CPAEntry | CPAEntryCollection,\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n): CPAEntry | CPAEntryCollection => {\n  const modifiedCPAResponse = clone(\n    CPAResponse as unknown as Record<string, unknown>,\n  ) as unknown as CPAEntry | CPAEntryCollection;\n\n  // Entity collections\n  if (modifiedCPAResponse.sys && 'items' in (modifiedCPAResponse as CPAEntryCollection)) {\n    const collection = modifiedCPAResponse as CPAEntryCollection;\n    if (!collection.sys?.contentSourceMapsLookup) {\n      console.error('Content source maps lookup data is missing');\n      return collection;\n    }\n    const {\n      contentSourceMapsLookup: { fieldTypes, editorInterfaces },\n    } = collection.sys;\n    const { items, includes } = collection;\n\n    items.forEach((target) =>\n      applyEncoding(target, fieldTypes, editorInterfaces, targetOrigin, platform),\n    );\n    if (includes && includes.Entry) {\n      includes.Entry.forEach((entry) =>\n        applyEncoding(entry, fieldTypes, editorInterfaces, targetOrigin, platform),\n      );\n    }\n    if (includes && includes.Asset) {\n      includes.Asset.forEach((asset) =>\n        applyEncoding(asset, fieldTypes, editorInterfaces, targetOrigin, platform),\n      );\n    }\n    // Single entity\n  } else {\n    const entry = modifiedCPAResponse as CPAEntry;\n    if (!entry.sys.contentSourceMapsLookup) {\n      console.error('Content source maps lookup data is missing');\n      return entry;\n    }\n\n    applyEncoding(\n      entry,\n      entry.sys.contentSourceMapsLookup.fieldTypes,\n      entry.sys.contentSourceMapsLookup.editorInterfaces,\n      targetOrigin,\n      platform,\n    );\n  }\n\n  return modifiedCPAResponse;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}