{"ast":null,"code":"var W = {\n    0: 8203,\n    1: 8204,\n    2: 8205,\n    3: 8290,\n    4: 8291,\n    5: 8288,\n    6: 65279,\n    7: 8289,\n    8: 119155,\n    9: 119156,\n    a: 119157,\n    b: 119158,\n    c: 119159,\n    d: 119160,\n    e: 119161,\n    f: 119162\n  },\n  L = {\n    0: 8203,\n    1: 8204,\n    2: 8205,\n    3: 65279\n  },\n  j = new Array(4).fill(String.fromCodePoint(L[0])).join(\"\"),\n  V = \"\\0\";\nfunction U(t) {\n  let n = JSON.stringify(t);\n  return `${j}${Array.from(n).map(o => {\n    let e = o.charCodeAt(0);\n    if (e > 255) throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${n} on character ${o} (${e})`);\n    return Array.from(e.toString(4).padStart(4, \"0\")).map(r => String.fromCodePoint(L[r])).join(\"\");\n  }).join(\"\")}`;\n}\nfunction Z(t) {\n  return !Number.isNaN(Number(t)) || /[a-z]/i.test(t) && !/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t) ? !1 : !!Date.parse(t);\n}\nfunction q(t) {\n  try {\n    new URL(t, t.startsWith(\"/\") ? \"https://acme.com\" : void 0);\n  } catch (n) {\n    return !1;\n  }\n  return !0;\n}\nfunction G(t, n, o = \"auto\") {\n  return o === !0 || o === \"auto\" && (Z(t) || q(t)) ? t : `${t}${U(n)}`;\n}\nvar H = Object.fromEntries(Object.entries(L).map(t => t.reverse())),\n  k = Object.fromEntries(Object.entries(W).map(t => t.reverse())),\n  K = `${Object.values(W).map(t => `\\\\u{${t.toString(16)}}`).join(\"\")}`,\n  O = new RegExp(`[${K}]{4,}`, \"gu\");\nfunction X(t) {\n  let n = t.match(O);\n  if (n) return Y(n[0], !0)[0];\n}\nfunction Y(t, n = !1) {\n  let o = Array.from(t);\n  if (o.length % 2 === 0) {\n    if (o.length % 4 || !t.startsWith(j)) return ee(o, n);\n  } else throw new Error(\"Encoded data has invalid length\");\n  let e = [];\n  for (let r = o.length * 0.25; r--;) {\n    let s = o.slice(r * 4, r * 4 + 4).map(c => H[c.codePointAt(0)]).join(\"\");\n    e.unshift(String.fromCharCode(parseInt(s, 4)));\n  }\n  if (n) {\n    e.shift();\n    let r = e.indexOf(V);\n    return r === -1 && (r = e.length), [JSON.parse(e.slice(0, r).join(\"\"))];\n  }\n  return e.join(\"\").split(V).filter(Boolean).map(r => JSON.parse(r));\n}\nfunction ee(t, n) {\n  var o;\n  let e = [];\n  for (let i = t.length * 0.5; i--;) {\n    let u = `${k[t[i * 2].codePointAt(0)]}${k[t[i * 2 + 1].codePointAt(0)]}`;\n    e.unshift(String.fromCharCode(parseInt(u, 16)));\n  }\n  let r = [],\n    s = [e.join(\"\")],\n    c = 10;\n  for (; s.length;) {\n    let i = s.shift();\n    try {\n      if (r.push(JSON.parse(i)), n) return r;\n    } catch (u) {\n      if (!c--) throw u;\n      let a = +((o = u.message.match(/\\sposition\\s(\\d+)$/)) == null ? void 0 : o[1]);\n      if (!a) throw u;\n      s.unshift(i.substring(0, a), i.substring(a));\n    }\n  }\n  return r;\n}\nfunction te(t) {\n  var n;\n  return {\n    cleaned: t.replace(O, \"\"),\n    encoded: ((n = t.match(O)) == null ? void 0 : n[0]) || \"\"\n  };\n}\nfunction w(t, n) {\n  return G(t, n);\n}\nfunction ce(t) {\n  return U(t);\n}\nfunction ie(t) {\n  return X(t);\n}\nfunction ae(t) {\n  return te(t);\n}\nvar x, F;\nfunction ne() {\n  if (F) return x;\n  F = 1;\n  var t = Object.prototype.hasOwnProperty,\n    n = Object.prototype.toString;\n  return x = function (e, r, s) {\n    if (n.call(r) !== \"[object Function]\") throw new TypeError(\"iterator must be a function\");\n    var c = e.length;\n    if (c === +c) for (var i = 0; i < c; i++) r.call(s, e[i], i, e);else for (var u in e) t.call(e, u) && r.call(s, e[u], u, e);\n  }, x;\n}\nvar I, _;\nfunction re() {\n  if (_) return I;\n  _ = 1;\n  var t = ne();\n  I = n;\n  function n(o, e, r) {\n    if (arguments.length === 3) return n.set(o, e, r);\n    if (arguments.length === 2) return n.get(o, e);\n    var s = n.bind(n, o);\n    for (var c in n) n.hasOwnProperty(c) && (s[c] = n[c].bind(s, o));\n    return s;\n  }\n  return n.get = function (e, r) {\n    for (var s = Array.isArray(r) ? r : n.parse(r), c = 0; c < s.length; ++c) {\n      var i = s[c];\n      if (!(typeof e == \"object\" && i in e)) throw new Error(\"Invalid reference token: \" + i);\n      e = e[i];\n    }\n    return e;\n  }, n.set = function (e, r, s) {\n    var c = Array.isArray(r) ? r : n.parse(r),\n      i = c[0];\n    if (c.length === 0) throw Error(\"Can not set the root object\");\n    for (var u = 0; u < c.length - 1; ++u) {\n      var a = c[u];\n      typeof a != \"string\" && typeof a != \"number\" && (a = String(a)), !(a === \"__proto__\" || a === \"constructor\" || a === \"prototype\") && (a === \"-\" && Array.isArray(e) && (a = e.length), i = c[u + 1], a in e || (i.match(/^(\\d+|-)$/) ? e[a] = [] : e[a] = {}), e = e[a]);\n    }\n    return i === \"-\" && Array.isArray(e) && (i = e.length), e[i] = s, this;\n  }, n.remove = function (o, e) {\n    var r = Array.isArray(e) ? e : n.parse(e),\n      s = r[r.length - 1];\n    if (s === void 0) throw new Error('Invalid JSON pointer for remove: \"' + e + '\"');\n    var c = n.get(o, r.slice(0, -1));\n    if (Array.isArray(c)) {\n      var i = +s;\n      if (s === \"\" && isNaN(i)) throw new Error('Invalid array index: \"' + s + '\"');\n      Array.prototype.splice.call(c, i, 1);\n    } else delete c[s];\n  }, n.dict = function (e, r) {\n    var s = {};\n    return n.walk(e, function (c, i) {\n      s[i] = c;\n    }, r), s;\n  }, n.walk = function (e, r, s) {\n    var c = [];\n    s = s || function (i) {\n      var u = Object.prototype.toString.call(i);\n      return u === \"[object Object]\" || u === \"[object Array]\";\n    }, function i(u) {\n      t(u, function (a, l) {\n        c.push(String(l)), s(a) ? i(a) : r(a, n.compile(c)), c.pop();\n      });\n    }(e);\n  }, n.has = function (e, r) {\n    try {\n      n.get(e, r);\n    } catch (s) {\n      return !1;\n    }\n    return !0;\n  }, n.escape = function (e) {\n    return e.toString().replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n  }, n.unescape = function (e) {\n    return e.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n  }, n.parse = function (e) {\n    if (e === \"\") return [];\n    if (e.charAt(0) !== \"/\") throw new Error(\"Invalid JSON pointer: \" + e);\n    return e.substring(1).split(/\\//).map(n.unescape);\n  }, n.compile = function (e) {\n    return e.length === 0 ? \"\" : \"/\" + e.map(n.escape).join(\"/\");\n  }, I;\n}\nvar p = re();\nconst oe = ({\n    pointer: t,\n    mappings: n,\n    data: o,\n    hiddenStrings: e\n  }) => {\n    const r = n[t];\n    if (r) {\n      delete n[t];\n      const s = C(o, t);\n      for (const c of s) {\n        n[c] = r;\n        const i = p.get(o, c),\n          u = w(i, e);\n        p.set(o, c, u);\n      }\n    } else {\n      const s = C(o, t);\n      for (const c of s) {\n        const i = p.get(o, c),\n          u = w(i, e);\n        p.set(o, c, u);\n      }\n    }\n  },\n  C = (t, n = \"\") => {\n    const o = [],\n      e = p.get(t, n);\n    if (e.content) for (let r = 0; r < e.content.length; r++) e.content[r].nodeType === \"text\" ? o.push(`${n}/content/${r}/value`) : o.push(...C(t, `${n}/content/${r}`));\n    return o;\n  },\n  b = ({\n    entityId: t,\n    entityType: n,\n    space: o,\n    environment: e,\n    field: r,\n    locale: s,\n    editorInterface: c,\n    fieldType: i,\n    targetOrigin: u,\n    platform: a\n  }) => {\n    const d = {\n      origin: \"contentful.com\",\n      href: `${`${u || \"https://app.contentful.com\"}/spaces/${o}/environments/${e}`}/${n === \"Entry\" ? \"entries\" : \"assets\"}/${t}/?focusedField=${r}&focusedLocale=${s}&source=vercel-content-link`,\n      contentful: {\n        editorInterface: c,\n        fieldType: i\n      }\n    };\n    return a === \"vercel\" && delete d.contentful, d;\n  },\n  B = t => [\"builtin\", \"sidebar-builtin\", \"editor-builtin\"].includes(t),\n  D = t => se.includes(t);\nfunction Q(t) {\n  if (typeof structuredClone == \"function\") return structuredClone(t);\n  try {\n    return JSON.parse(JSON.stringify(t));\n  } catch (n) {\n    return console.warn(\"Failed to clone data:\", t, n), t;\n  }\n}\nconst se = [\"singleLine\", \"tagEditor\", \"listInput\", \"checkbox\", \"richTextEditor\", \"multipleLine\"];\nfunction P(t, n, o, e, r, s, c) {\n  const i = c ? n[c] : n;\n  switch (t) {\n    case \"Symbol\":\n      {\n        const u = w(i, o);\n        p.set(e, r, u);\n        break;\n      }\n    case \"Text\":\n      {\n        const u = w(i, o);\n        p.set(e, r, u);\n        break;\n      }\n    case \"RichText\":\n      {\n        oe({\n          pointer: \"\",\n          mappings: s,\n          data: i,\n          hiddenStrings: o\n        });\n        break;\n      }\n    case \"Array\":\n      {\n        const u = i.map(a => typeof a == \"string\" ? w(a, o) : a);\n        p.set(e, r, u);\n        break;\n      }\n  }\n}\nconst ue = (t, n, o) => {\n    if (!t || !t.extensions || !t.extensions.contentSourceMaps) return console.error(\"GraphQL response does not contain Content Source Maps information.\", t), t;\n    const e = Q(t),\n      {\n        spaces: r,\n        environments: s,\n        editorInterfaces: c,\n        fields: i,\n        locales: u,\n        entries: a,\n        assets: l,\n        mappings: m,\n        fieldTypes: v\n      } = e.extensions.contentSourceMaps,\n      y = e;\n    for (const d in m) {\n      const {\n          source: f\n        } = m[d],\n        h = \"entry\" in f ? a[f.entry] : l[f.asset],\n        M = \"entry\" in f ? \"Entry\" : \"Asset\";\n      if (!h) return e;\n      const g = r[h.space],\n        A = s[h.environment],\n        E = h.id,\n        S = i[f.field],\n        T = u[f.locale],\n        N = c[f.editorInterface],\n        J = v[f.fieldType];\n      if (!(B(N.widgetNamespace) && !D(N.widgetId)) && p.has(y, d)) {\n        const R = p.get(y, d);\n        if (R !== null) {\n          const z = b({\n            entityId: E,\n            entityType: M,\n            space: g,\n            environment: A,\n            field: S,\n            locale: T,\n            editorInterface: N,\n            fieldType: J,\n            targetOrigin: n,\n            platform: o\n          });\n          P(J, R, z, y, d, m);\n        }\n      }\n    }\n    return e;\n  },\n  $ = (t, n, o, e, r) => {\n    if (!t.fields) return;\n    const {\n      contentSourceMaps: s\n    } = t.sys;\n    if (!s) {\n      console.error(\"Content source maps data is missing\");\n      return;\n    }\n    const {\n      mappings: c\n    } = s;\n    for (const i in c) {\n      const {\n          source: u\n        } = c[i],\n        a = t.sys.space.sys.id,\n        l = t.sys.environment.sys.id,\n        m = t.sys.id,\n        v = t.sys.type,\n        y = n[u.fieldType],\n        d = o[u.editorInterface];\n      if (B(d.widgetNamespace) && !D(d.widgetId)) continue;\n      const f = i.startsWith(\"/\") ? i : `/${i}`;\n      if (p.has(t, f)) {\n        const h = p.get(t, f);\n        if (h === null) return;\n        const g = f.split(\"/\").pop();\n        if (!g) {\n          console.error(\"Field name could not be extracted from the pointer\", f);\n          return;\n        }\n        const A = t.sys.locale;\n        if (A) {\n          const E = b({\n            entityId: m,\n            entityType: v,\n            space: a,\n            environment: l,\n            field: g,\n            locale: A,\n            editorInterface: d,\n            fieldType: y,\n            targetOrigin: e,\n            platform: r\n          });\n          P(y, h, E, t, f, c);\n        } else Object.keys(h).forEach(S => {\n          const T = b({\n            entityId: m,\n            entityType: v,\n            space: a,\n            environment: l,\n            field: g,\n            locale: S,\n            editorInterface: d,\n            fieldType: y,\n            targetOrigin: e,\n            platform: r\n          });\n          P(y, h, T, t, `${f}/${S}`, c, S);\n        });\n      }\n    }\n  },\n  fe = (t, n, o) => {\n    var r;\n    const e = Q(t);\n    if (e.sys && \"items\" in e) {\n      const s = e;\n      if (!((r = s.sys) != null && r.contentSourceMapsLookup)) return console.error(\"Content source maps lookup data is missing\"), s;\n      const {\n          contentSourceMapsLookup: {\n            fieldTypes: c,\n            editorInterfaces: i\n          }\n        } = s.sys,\n        {\n          items: u,\n          includes: a\n        } = s;\n      u.forEach(l => $(l, c, i, n, o)), a && a.Entry && a.Entry.forEach(l => $(l, c, i, n, o)), a && a.Asset && a.Asset.forEach(l => $(l, c, i, n, o));\n    } else {\n      const s = e;\n      if (!s.sys.contentSourceMapsLookup) return console.error(\"Content source maps lookup data is missing\"), s;\n      $(s, s.sys.contentSourceMapsLookup.fieldTypes, s.sys.contentSourceMapsLookup.editorInterfaces, n, o);\n    }\n    return e;\n  };\nexport { se as SUPPORTED_WIDGETS, Q as clone, w as combine, b as createSourceMapMetadata, ie as decode, ce as encode, fe as encodeCPAResponse, P as encodeField, ue as encodeGraphQLResponse, oe as encodeRichTextValue, B as isBuiltinNamespace, D as isSupportedWidget, ae as splitEncoding };","map":{"version":3,"names":["W","a","b","c","d","e","f","L","j","Array","fill","String","fromCodePoint","join","V","U","t","n","JSON","stringify","from","map","o","charCodeAt","Error","toString","padStart","r","Z","Number","isNaN","test","Date","parse","q","URL","startsWith","G","H","Object","fromEntries","entries","reverse","k","K","values","O","RegExp","X","match","Y","length","ee","s","slice","codePointAt","unshift","fromCharCode","parseInt","shift","indexOf","split","filter","Boolean","i","u","push","message","substring","te","cleaned","replace","encoded","w","ce","ie","ae","prototype","hasOwnProperty","x","foreach","call","TypeError","ne","I","arguments","set","get","bind","isArray","remove","splice","dict","walk","l","compile","pop","has","escape","unescape","charAt","oe","encodeRichTextValue","pointer","mappings","data","hiddenStrings","C","p","findRichTextNodes","content","nodeType","createSourceMapMetadata","entityId","entityType","space","environment","field","locale","editorInterface","fieldType","targetOrigin","platform","origin","href","contentful","B","includes","D","se","Q","structuredClone","console","warn","P","ue","encodeGraphQLResponse","extensions","contentSourceMaps","error","spaces","environments","editorInterfaces","fields","locales","assets","m","fieldTypes","v","y","source","h","entry","asset","M","g","A","E","id","S","T","N","J","widgetNamespace","widgetId","R","z","$","applyEncoding","sys","type","keys","forEach","fe","encodeCPAResponse","contentSourceMapsLookup","items","Entry","Asset"],"sources":["/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/node_modules/@vercel/stega/dist/index.mjs","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/@contentful/content-source-maps/src/encode.ts","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/node_modules/foreach/index.js","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/node_modules/json-pointer/index.js","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/@contentful/content-source-maps/src/richText.ts","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/@contentful/content-source-maps/src/utils.ts","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/@contentful/content-source-maps/src/graphql/encodeGraphQLResponse.ts","/Applications/XAMPP/xamppfiles/htdocs/ETA-TRADE/node_modules/@contentful/content-source-maps/src/rest/encodeCPAResponse.ts"],"sourcesContent":["var s={0:8203,1:8204,2:8205,3:8290,4:8291,5:8288,6:65279,7:8289,8:119155,9:119156,a:119157,b:119158,c:119159,d:119160,e:119161,f:119162},c={0:8203,1:8204,2:8205,3:65279},u=new Array(4).fill(String.fromCodePoint(c[0])).join(\"\"),m=String.fromCharCode(0);function E(t){let e=JSON.stringify(t);return`${u}${Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(4).padStart(4,\"0\")).map(o=>String.fromCodePoint(c[o])).join(\"\")}).join(\"\")}`}function y(t){let e=JSON.stringify(t);return Array.from(e).map(r=>{let n=r.charCodeAt(0);if(n>255)throw new Error(`Only ASCII edit info can be encoded. Error attempting to encode ${e} on character ${r} (${n})`);return Array.from(n.toString(16).padStart(2,\"0\")).map(o=>String.fromCodePoint(s[o])).join(\"\")}).join(\"\")}function I(t){return!Number.isNaN(Number(t))||/[a-z]/i.test(t)&&!/\\d+(?:[-:\\/]\\d+){2}(?:T\\d+(?:[-:\\/]\\d+){1,2}(\\.\\d+)?Z?)?/.test(t)?!1:Boolean(Date.parse(t))}function T(t){try{new URL(t,t.startsWith(\"/\")?\"https://acme.com\":void 0)}catch{return!1}return!0}function C(t,e,r=\"auto\"){return r===!0||r===\"auto\"&&(I(t)||T(t))?t:`${t}${E(e)}`}var x=Object.fromEntries(Object.entries(c).map(t=>t.reverse())),g=Object.fromEntries(Object.entries(s).map(t=>t.reverse())),S=`${Object.values(s).map(t=>`\\\\u{${t.toString(16)}}`).join(\"\")}`,f=new RegExp(`[${S}]{4,}`,\"gu\");function G(t){let e=t.match(f);if(!!e)return h(e[0],!0)[0]}function $(t){let e=t.match(f);if(!!e)return e.map(r=>h(r)).flat()}function h(t,e=!1){let r=Array.from(t);if(r.length%2===0){if(r.length%4||!t.startsWith(u))return A(r,e)}else throw new Error(\"Encoded data has invalid length\");let n=[];for(let o=r.length*.25;o--;){let p=r.slice(o*4,o*4+4).map(d=>x[d.codePointAt(0)]).join(\"\");n.unshift(String.fromCharCode(parseInt(p,4)))}if(e){n.shift();let o=n.indexOf(m);return o===-1&&(o=n.length),[JSON.parse(n.slice(0,o).join(\"\"))]}return n.join(\"\").split(m).filter(Boolean).map(o=>JSON.parse(o))}function A(t,e){var d;let r=[];for(let i=t.length*.5;i--;){let a=`${g[t[i*2].codePointAt(0)]}${g[t[i*2+1].codePointAt(0)]}`;r.unshift(String.fromCharCode(parseInt(a,16)))}let n=[],o=[r.join(\"\")],p=10;for(;o.length;){let i=o.shift();try{if(n.push(JSON.parse(i)),e)return n}catch(a){if(!p--)throw a;let l=+((d=a.message.match(/\\sposition\\s(\\d+)$/))==null?void 0:d[1]);if(!l)throw a;o.unshift(i.substring(0,l),i.substring(l))}}return n}function _(t){var e;return{cleaned:t.replace(f,\"\"),encoded:((e=t.match(f))==null?void 0:e[0])||\"\"}}function O(t){return t&&JSON.parse(_(JSON.stringify(t)).cleaned)}export{f as VERCEL_STEGA_REGEX,y as legacyStegaEncode,O as vercelStegaClean,C as vercelStegaCombine,G as vercelStegaDecode,$ as vercelStegaDecodeAll,E as vercelStegaEncode,_ as vercelStegaSplit};\n","import {\n  vercelStegaCombine,\n  vercelStegaDecode,\n  vercelStegaEncode,\n  vercelStegaSplit,\n} from '@vercel/stega';\n\nimport type { SourceMapMetadata } from './types.js';\n\nexport function combine(text: string, metadata: SourceMapMetadata): string {\n  return vercelStegaCombine(text, metadata);\n}\n\nexport function encode(metadata: SourceMapMetadata): string {\n  return vercelStegaEncode(metadata);\n}\n\nexport function decode(text: string): SourceMapMetadata | undefined {\n  return vercelStegaDecode(text);\n}\n\nexport function splitEncoding(text: string): {\n  /** The original string with encoded substring removed */\n  cleaned: string;\n  /** The encoded substring from the original string */\n  encoded: string;\n} {\n  return vercelStegaSplit(text);\n}\n","\nvar hasOwn = Object.prototype.hasOwnProperty;\nvar toString = Object.prototype.toString;\n\nmodule.exports = function forEach (obj, fn, ctx) {\n    if (toString.call(fn) !== '[object Function]') {\n        throw new TypeError('iterator must be a function');\n    }\n    var l = obj.length;\n    if (l === +l) {\n        for (var i = 0; i < l; i++) {\n            fn.call(ctx, obj[i], i, obj);\n        }\n    } else {\n        for (var k in obj) {\n            if (hasOwn.call(obj, k)) {\n                fn.call(ctx, obj[k], k, obj);\n            }\n        }\n    }\n};\n\n","'use strict';\n\nvar each = require('foreach');\nmodule.exports = api;\n\n\n/**\n * Convenience wrapper around the api.\n * Calls `.get` when called with an `object` and a `pointer`.\n * Calls `.set` when also called with `value`.\n * If only supplied `object`, returns a partially applied function, mapped to the object.\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n * @returns {*}\n */\n\nfunction api (obj, pointer, value) {\n    // .set()\n    if (arguments.length === 3) {\n        return api.set(obj, pointer, value);\n    }\n    // .get()\n    if (arguments.length === 2) {\n        return api.get(obj, pointer);\n    }\n    // Return a partially applied function on `obj`.\n    var wrapped = api.bind(api, obj);\n\n    // Support for oo style\n    for (var name in api) {\n        if (api.hasOwnProperty(name)) {\n            wrapped[name] = api[name].bind(wrapped, obj);\n        }\n    }\n    return wrapped;\n}\n\n\n/**\n * Lookup a json pointer in an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @returns {*}\n */\napi.get = function get (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n\n    for (var i = 0; i < refTokens.length; ++i) {\n        var tok = refTokens[i];\n        if (!(typeof obj == 'object' && tok in obj)) {\n            throw new Error('Invalid reference token: ' + tok);\n        }\n        obj = obj[tok];\n    }\n    return obj;\n};\n\n/**\n * Sets a value on an object\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n * @param value\n */\napi.set = function set (obj, pointer, value) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer),\n      nextTok = refTokens[0];\n\n    if (refTokens.length === 0) {\n      throw Error('Can not set the root object');\n    }\n\n    for (var i = 0; i < refTokens.length - 1; ++i) {\n        var tok = refTokens[i];\n        if (typeof tok !== 'string' && typeof tok !== 'number') {\n          tok = String(tok)\n        }\n        if (tok === \"__proto__\" || tok === \"constructor\" || tok === \"prototype\") {\n            continue\n        }\n        if (tok === '-' && Array.isArray(obj)) {\n          tok = obj.length;\n        }\n        nextTok = refTokens[i + 1];\n\n        if (!(tok in obj)) {\n            if (nextTok.match(/^(\\d+|-)$/)) {\n                obj[tok] = [];\n            } else {\n                obj[tok] = {};\n            }\n        }\n        obj = obj[tok];\n    }\n    if (nextTok === '-' && Array.isArray(obj)) {\n      nextTok = obj.length;\n    }\n    obj[nextTok] = value;\n    return this;\n};\n\n/**\n * Removes an attribute\n *\n * @param {Object} obj\n * @param {String|Array} pointer\n */\napi.remove = function (obj, pointer) {\n    var refTokens = Array.isArray(pointer) ? pointer : api.parse(pointer);\n    var finalToken = refTokens[refTokens.length -1];\n    if (finalToken === undefined) {\n        throw new Error('Invalid JSON pointer for remove: \"' + pointer + '\"');\n    }\n\n    var parent = api.get(obj, refTokens.slice(0, -1));\n    if (Array.isArray(parent)) {\n      var index = +finalToken;\n      if (finalToken === '' && isNaN(index)) {\n        throw new Error('Invalid array index: \"' + finalToken + '\"');\n      }\n\n      Array.prototype.splice.call(parent, index, 1);\n    } else {\n      delete parent[finalToken];\n    }\n};\n\n/**\n * Returns a (pointer -> value) dictionary for an object\n *\n * @param obj\n * @param {function} descend\n * @returns {}\n */\napi.dict = function dict (obj, descend) {\n    var results = {};\n    api.walk(obj, function (value, pointer) {\n        results[pointer] = value;\n    }, descend);\n    return results;\n};\n\n/**\n * Iterates over an object\n * Iterator: function (value, pointer) {}\n *\n * @param obj\n * @param {function} iterator\n * @param {function} descend\n */\napi.walk = function walk (obj, iterator, descend) {\n    var refTokens = [];\n\n    descend = descend || function (value) {\n        var type = Object.prototype.toString.call(value);\n        return type === '[object Object]' || type === '[object Array]';\n    };\n\n    (function next (cur) {\n        each(cur, function (value, key) {\n            refTokens.push(String(key));\n            if (descend(value)) {\n                next(value);\n            } else {\n                iterator(value, api.compile(refTokens));\n            }\n            refTokens.pop();\n        });\n    }(obj));\n};\n\n/**\n * Tests if an object has a value for a json pointer\n *\n * @param obj\n * @param pointer\n * @returns {boolean}\n */\napi.has = function has (obj, pointer) {\n    try {\n        api.get(obj, pointer);\n    } catch (e) {\n        return false;\n    }\n    return true;\n};\n\n/**\n * Escapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.escape = function escape (str) {\n    return str.toString().replace(/~/g, '~0').replace(/\\//g, '~1');\n};\n\n/**\n * Unescapes a reference token\n *\n * @param str\n * @returns {string}\n */\napi.unescape = function unescape (str) {\n    return str.replace(/~1/g, '/').replace(/~0/g, '~');\n};\n\n/**\n * Converts a json pointer into a array of reference tokens\n *\n * @param pointer\n * @returns {Array}\n */\napi.parse = function parse (pointer) {\n    if (pointer === '') { return []; }\n    if (pointer.charAt(0) !== '/') { throw new Error('Invalid JSON pointer: ' + pointer); }\n    return pointer.substring(1).split(/\\//).map(api.unescape);\n};\n\n/**\n * Builds a json pointer from a array of reference tokens\n *\n * @param refTokens\n * @returns {string}\n */\napi.compile = function compile (refTokens) {\n    if (refTokens.length === 0) { return ''; }\n    return '/' + refTokens.map(api.escape).join('/');\n};\n","import { get, set } from 'json-pointer';\n\nimport { combine } from './encode.js';\nimport type { CPAMappings, GraphQLMappings, SourceMapMetadata } from './types.js';\n\nexport const encodeRichTextValue = ({\n  pointer,\n  mappings,\n  data,\n  hiddenStrings,\n}: {\n  pointer: string;\n  mappings: CPAMappings | GraphQLMappings;\n  data: Node;\n  hiddenStrings: SourceMapMetadata;\n}) => {\n  const source = mappings[pointer];\n\n  // Only proceed with mapping if we have a valid source\n  if (source) {\n    // We can now safely delete the original pointer as we've preserved the source\n    delete mappings[pointer];\n\n    const textNodes = findRichTextNodes(data, pointer);\n    for (const textNode of textNodes) {\n      mappings[textNode] = source;\n      const currentTextNodeValue = get(data, textNode);\n      const encodedValue = combine(currentTextNodeValue, hiddenStrings);\n      set(data, textNode, encodedValue);\n    }\n  } else {\n    // If there's no source mapping, just encode the text nodes without creating mappings\n    const textNodes = findRichTextNodes(data, pointer);\n    for (const textNode of textNodes) {\n      const currentTextNodeValue = get(data, textNode);\n      const encodedValue = combine(currentTextNodeValue, hiddenStrings);\n      set(data, textNode, encodedValue);\n    }\n  }\n};\n\nconst findRichTextNodes = (data: Node, currentPath = ''): string[] => {\n  const textNodes = [];\n  const node = get(data, currentPath);\n\n  if (node.content) {\n    for (let i = 0; i < node.content.length; i++) {\n      if (node.content[i].nodeType === 'text') {\n        textNodes.push(`${currentPath}/content/${i}/value`);\n      } else {\n        textNodes.push(...findRichTextNodes(data, `${currentPath}/content/${i}`));\n      }\n    }\n  }\n\n  return textNodes;\n};\n","import { set } from 'json-pointer';\n\nimport { combine } from './encode.js';\nimport { encodeRichTextValue } from './richText.js';\nimport type {\n  CPAEntry,\n  CPAMappings,\n  CreateSourceMapParams,\n  FieldType,\n  GraphQLMappings,\n  GraphQLResponse,\n  SourceMapMetadata,\n  WidgetId,\n  WidgetNamespace,\n} from './types.js';\n\nexport const createSourceMapMetadata = ({\n  entityId,\n  entityType,\n  space,\n  environment,\n  field,\n  locale,\n  editorInterface,\n  fieldType,\n  targetOrigin,\n  platform,\n}: CreateSourceMapParams): SourceMapMetadata => {\n  const targetOriginUrl = targetOrigin || 'https://app.contentful.com';\n  const basePath = `${targetOriginUrl}/spaces/${space}/environments/${environment}`;\n  const entityRoute = entityType === 'Entry' ? 'entries' : 'assets';\n  const href = `${basePath}/${entityRoute}/${entityId}/?focusedField=${field}&focusedLocale=${locale}&source=vercel-content-link`;\n\n  const result: SourceMapMetadata = {\n    origin: 'contentful.com',\n    href,\n    contentful: {\n      editorInterface,\n      fieldType,\n    },\n  };\n\n  // If the user has specified a platform, we remove the fields that are not relevant to that platform\n  if (platform === 'vercel') {\n    delete result.contentful;\n  }\n\n  return result;\n};\n\nexport const isBuiltinNamespace = (namespace: WidgetNamespace) =>\n  ['builtin', 'sidebar-builtin', 'editor-builtin'].includes(namespace);\nexport const isSupportedWidget = (widgetId: WidgetId) => SUPPORTED_WIDGETS.includes(widgetId);\n\n/**\n * Clones the incoming element into a new one, to prevent modification on the original object\n * Hint: It uses the structuredClone which is only available in modern browsers,\n * for older one it uses the JSON.parse(JSON.stringify) hack.\n */\nexport function clone<T extends Record<string, unknown> | Array<unknown>>(incoming: T): T {\n  if (typeof structuredClone === 'function') {\n    return structuredClone(incoming);\n  }\n\n  try {\n    return JSON.parse(JSON.stringify(incoming));\n  } catch (err) {\n    console.warn('Failed to clone data:', incoming, err);\n    return incoming;\n  }\n}\n\nexport const SUPPORTED_WIDGETS: WidgetId[] = [\n  'singleLine',\n  'tagEditor',\n  'listInput',\n  'checkbox',\n  'richTextEditor',\n  'multipleLine',\n];\n\nexport function encodeField(\n  fieldType: FieldType,\n  currentValue: any,\n  hiddenStrings: SourceMapMetadata,\n  target: GraphQLResponse | CPAEntry,\n  pointer: string,\n  mappings: CPAMappings | GraphQLMappings,\n  locale?: string,\n) {\n  // Determine the value based on locale (if provided)\n  const value = locale ? currentValue[locale] : currentValue;\n\n  // Process based on fieldType\n  switch (fieldType) {\n    case 'Symbol': {\n      const encodedValue = combine(value, hiddenStrings);\n      set(target, pointer, encodedValue);\n      break;\n    }\n\n    case 'Text': {\n      const encodedValue = combine(value, hiddenStrings);\n      set(target, pointer, encodedValue);\n      break;\n    }\n\n    case 'RichText': {\n      encodeRichTextValue({\n        pointer: '',\n        mappings,\n        data: value,\n        hiddenStrings,\n      });\n      break;\n    }\n\n    case 'Array': {\n      const encodedArray = value.map((item: unknown) => {\n        if (typeof item === 'string') {\n          return combine(item, hiddenStrings);\n        } else {\n          return item; // Return the item unchanged if it's not a string\n        }\n      });\n      set(target, pointer, encodedArray);\n      break;\n    }\n  }\n}\n","import { get, has } from 'json-pointer';\n\nimport type { CreateSourceMapParams } from '../types.js';\nimport {\n  clone,\n  createSourceMapMetadata,\n  encodeField,\n  isBuiltinNamespace,\n  isSupportedWidget,\n} from '../utils.js';\n\nexport const encodeGraphQLResponse = <TResponse extends { data: any; extensions: any }>(\n  originalGraphqlResponse: TResponse,\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n): TResponse => {\n  if (\n    !originalGraphqlResponse ||\n    !originalGraphqlResponse.extensions ||\n    !originalGraphqlResponse.extensions.contentSourceMaps\n  ) {\n    console.error(\n      'GraphQL response does not contain Content Source Maps information.',\n      originalGraphqlResponse,\n    );\n    return originalGraphqlResponse;\n  }\n  const modifiedGraphqlResponse = clone(originalGraphqlResponse);\n  const {\n    spaces,\n    environments,\n    editorInterfaces,\n    fields,\n    locales,\n    entries,\n    assets,\n    mappings,\n    fieldTypes,\n  } = modifiedGraphqlResponse.extensions.contentSourceMaps;\n  const target = modifiedGraphqlResponse;\n\n  for (const pointer in mappings) {\n    const { source } = mappings[pointer];\n\n    const entity = 'entry' in source ? entries[source.entry] : assets[source.asset];\n    const entityType = 'entry' in source ? 'Entry' : 'Asset';\n\n    if (!entity) {\n      return modifiedGraphqlResponse;\n    }\n\n    const space = spaces[entity.space];\n    const environment = environments[entity.environment];\n    const entityId = entity.id;\n    const field = fields[source.field];\n    const locale = locales[source.locale];\n    const editorInterface = editorInterfaces[source.editorInterface];\n    const fieldType = fieldTypes[source.fieldType];\n\n    // Skip unsupported widgets\n    if (\n      isBuiltinNamespace(editorInterface.widgetNamespace) &&\n      !isSupportedWidget(editorInterface.widgetId)\n    ) {\n      continue;\n    }\n\n    if (has(target, pointer)) {\n      const currentValue = get(target, pointer);\n\n      if (currentValue !== null) {\n        const hiddenStrings = createSourceMapMetadata({\n          entityId,\n          entityType,\n          space,\n          environment,\n          field,\n          locale,\n          editorInterface,\n          fieldType,\n          targetOrigin,\n          platform,\n        });\n\n        encodeField(fieldType, currentValue, hiddenStrings, target, pointer, mappings);\n      }\n    } else {\n      //@TODO - add Sentry logging\n      // console.warn(`Pointer ${pointer} not found in the entry`, target);\n    }\n  }\n  return modifiedGraphqlResponse;\n};\n","import { get, has } from 'json-pointer';\n\nimport type {\n  CPAEntry,\n  CPAEntryCollection,\n  EditorInterfaceSource,\n  FieldType,\n  CreateSourceMapParams,\n} from '../types.js';\nimport {\n  clone,\n  createSourceMapMetadata,\n  encodeField,\n  isBuiltinNamespace,\n  isSupportedWidget,\n} from '../utils.js';\n\nconst applyEncoding = (\n  target: CPAEntry,\n  fieldTypes: FieldType[],\n  editorInterfaces: EditorInterfaceSource[],\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n) => {\n  if (!target.fields) {\n    return;\n  }\n\n  const { contentSourceMaps } = target.sys;\n\n  if (!contentSourceMaps) {\n    console.error('Content source maps data is missing');\n    return;\n  }\n\n  const { mappings } = contentSourceMaps;\n\n  for (const pointer in mappings) {\n    const { source } = mappings[pointer];\n    const space = target.sys.space.sys.id;\n    const environment = target.sys.environment.sys.id;\n    const entityId = target.sys.id;\n    const entityType = target.sys.type;\n    const fieldType = fieldTypes[source.fieldType];\n    const editorInterface = editorInterfaces[source.editorInterface];\n\n    // Skip unsupported widgets\n    if (\n      isBuiltinNamespace(editorInterface.widgetNamespace) &&\n      !isSupportedWidget(editorInterface.widgetId)\n    ) {\n      continue;\n    }\n\n    const formattedPointer = pointer.startsWith('/') ? pointer : `/${pointer}`;\n\n    if (has(target, formattedPointer)) {\n      const currentValue = get(target, formattedPointer);\n      if (currentValue === null) {\n        return;\n      }\n      const fieldParts = formattedPointer.split('/'); // Split the pointer into parts\n      const field = fieldParts.pop(); // Get the last part, which is the field name\n      if (!field) {\n        console.error('Field name could not be extracted from the pointer', formattedPointer);\n        return;\n      }\n      const locale = target.sys.locale;\n\n      // Determine if we are dealing with multiple locale values in the response or just a single locale\n      if (locale) {\n        const hiddenStrings = createSourceMapMetadata({\n          entityId,\n          entityType,\n          space,\n          environment,\n          field,\n          locale,\n          editorInterface,\n          fieldType,\n          targetOrigin,\n          platform,\n        });\n\n        encodeField(fieldType, currentValue, hiddenStrings, target, formattedPointer, mappings);\n      } else {\n        const locales = Object.keys(currentValue);\n        locales.forEach((locale) => {\n          const hiddenStrings = createSourceMapMetadata({\n            entityId,\n            entityType,\n            space,\n            environment,\n            field,\n            locale,\n            editorInterface,\n            fieldType,\n            targetOrigin,\n            platform,\n          });\n\n          encodeField(\n            fieldType,\n            currentValue,\n            hiddenStrings,\n            target,\n            `${formattedPointer}/${locale}`,\n            mappings,\n            locale,\n          );\n        });\n      }\n    } else {\n      //@TODO - add Sentry logging\n      // console.warn(`Pointer ${pointer} not found in the entry`, target);\n    }\n  }\n};\n\nexport const encodeCPAResponse = (\n  CPAResponse: CPAEntry | CPAEntryCollection,\n  targetOrigin?: CreateSourceMapParams['targetOrigin'],\n  platform?: CreateSourceMapParams['platform'],\n): CPAEntry | CPAEntryCollection => {\n  const modifiedCPAResponse = clone(\n    CPAResponse as unknown as Record<string, unknown>,\n  ) as unknown as CPAEntry | CPAEntryCollection;\n\n  // Entity collections\n  if (modifiedCPAResponse.sys && 'items' in (modifiedCPAResponse as CPAEntryCollection)) {\n    const collection = modifiedCPAResponse as CPAEntryCollection;\n    if (!collection.sys?.contentSourceMapsLookup) {\n      console.error('Content source maps lookup data is missing');\n      return collection;\n    }\n    const {\n      contentSourceMapsLookup: { fieldTypes, editorInterfaces },\n    } = collection.sys;\n    const { items, includes } = collection;\n\n    items.forEach((target) =>\n      applyEncoding(target, fieldTypes, editorInterfaces, targetOrigin, platform),\n    );\n    if (includes && includes.Entry) {\n      includes.Entry.forEach((entry) =>\n        applyEncoding(entry, fieldTypes, editorInterfaces, targetOrigin, platform),\n      );\n    }\n    if (includes && includes.Asset) {\n      includes.Asset.forEach((asset) =>\n        applyEncoding(asset, fieldTypes, editorInterfaces, targetOrigin, platform),\n      );\n    }\n    // Single entity\n  } else {\n    const entry = modifiedCPAResponse as CPAEntry;\n    if (!entry.sys.contentSourceMapsLookup) {\n      console.error('Content source maps lookup data is missing');\n      return entry;\n    }\n\n    applyEncoding(\n      entry,\n      entry.sys.contentSourceMapsLookup.fieldTypes,\n      entry.sys.contentSourceMapsLookup.editorInterfaces,\n      targetOrigin,\n      platform,\n    );\n  }\n\n  return modifiedCPAResponse;\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}